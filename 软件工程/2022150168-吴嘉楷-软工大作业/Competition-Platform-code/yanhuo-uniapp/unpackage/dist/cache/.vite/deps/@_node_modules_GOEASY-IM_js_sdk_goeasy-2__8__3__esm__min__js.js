import "./chunk-Y2F7D3TJ.js";

// C:/Users/24312/Desktop/软件工程/大作业/Competition-Platform/yanhuo-uniapp/node_modules/GOEASY-IM/js_sdk/goeasy-2.8.3.esm.min.js
var e;
function t(e3, t2, s2, i2) {
  return new (s2 || (s2 = Promise))(function(n2, o2) {
    function r2(e4) {
      try {
        c2(i2.next(e4));
      } catch (e5) {
        o2(e5);
      }
    }
    function a2(e4) {
      try {
        c2(i2.throw(e4));
      } catch (e5) {
        o2(e5);
      }
    }
    function c2(e4) {
      var t3;
      e4.done ? n2(e4.value) : (t3 = e4.value, t3 instanceof s2 ? t3 : new s2(function(e5) {
        e5(t3);
      })).then(r2, a2);
    }
    c2((i2 = i2.apply(e3, t2 || [])).next());
  });
}
!function(e3) {
  e3.DISCONNECTED = "disconnected", e3.DISCONNECTING = "disconnecting", e3.CONNECTING = "connecting", e3.CONNECTED = "connected", e3.RECONNECTING = "reconnecting", e3.RECONNECTED = "reconnected", e3.EXPIRED_RECONNECTED = "reconnected", e3.CONNECT_FAILED = "connect_failed";
}(e || (e = {}));
var s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function i(e3) {
  if (e3.__esModule)
    return e3;
  var t2 = Object.defineProperty({}, "__esModule", { value: true });
  return Object.keys(e3).forEach(function(s2) {
    var i2 = Object.getOwnPropertyDescriptor(e3, s2);
    Object.defineProperty(t2, s2, i2.get ? i2 : { enumerable: true, get: function() {
      return e3[s2];
    } });
  }), t2;
}
var n = { exports: {} };
var o = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
var a = function(e3) {
  var t2 = e3, s2 = e3.indexOf("["), i2 = e3.indexOf("]");
  -1 != s2 && -1 != i2 && (e3 = e3.substring(0, s2) + e3.substring(s2, i2).replace(/:/g, ";") + e3.substring(i2, e3.length));
  for (var n2 = o.exec(e3 || ""), a2 = {}, c2 = 14; c2--; )
    a2[r[c2]] = n2[c2] || "";
  return -1 != s2 && -1 != i2 && (a2.source = t2, a2.host = a2.host.substring(1, a2.host.length - 1).replace(/;/g, ":"), a2.authority = a2.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), a2.ipv6uri = true), a2;
};
var c = { exports: {} };
var u = { exports: {} };
var l = 1e3;
var d = 60 * l;
var h = 60 * d;
var p = 24 * h;
var m = 365.25 * p;
var f = function(e3, t2) {
  t2 = t2 || {};
  var s2 = typeof e3;
  if ("string" === s2 && e3.length > 0)
    return function(e4) {
      if (e4 = String(e4), e4.length > 100)
        return;
      var t3 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e4);
      if (!t3)
        return;
      var s3 = parseFloat(t3[1]);
      switch ((t3[2] || "ms").toLowerCase()) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return s3 * m;
        case "days":
        case "day":
        case "d":
          return s3 * p;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return s3 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return s3 * d;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return s3 * l;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return s3;
        default:
          return;
      }
    }(e3);
  if ("number" === s2 && false === isNaN(e3))
    return t2.long ? function(e4) {
      return g(e4, p, "day") || g(e4, h, "hour") || g(e4, d, "minute") || g(e4, l, "second") || e4 + " ms";
    }(e3) : function(e4) {
      if (e4 >= p)
        return Math.round(e4 / p) + "d";
      if (e4 >= h)
        return Math.round(e4 / h) + "h";
      if (e4 >= d)
        return Math.round(e4 / d) + "m";
      if (e4 >= l)
        return Math.round(e4 / l) + "s";
      return e4 + "ms";
    }(e3);
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e3));
};
function g(e3, t2, s2) {
  if (!(e3 < t2))
    return e3 < 1.5 * t2 ? Math.floor(e3 / t2) + " " + s2 : Math.ceil(e3 / t2) + " " + s2 + "s";
}
!function(e3, t2) {
  function s2(e4) {
    var s3;
    function n2() {
      if (n2.enabled) {
        var e5 = n2, i3 = +/* @__PURE__ */ new Date(), o2 = i3 - (s3 || i3);
        e5.diff = o2, e5.prev = s3, e5.curr = i3, s3 = i3;
        for (var r2 = new Array(arguments.length), a2 = 0; a2 < r2.length; a2++)
          r2[a2] = arguments[a2];
        r2[0] = t2.coerce(r2[0]), "string" != typeof r2[0] && r2.unshift("%O");
        var c2 = 0;
        r2[0] = r2[0].replace(/%([a-zA-Z%])/g, function(s4, i4) {
          if ("%%" === s4)
            return s4;
          c2++;
          var n3 = t2.formatters[i4];
          if ("function" == typeof n3) {
            var o3 = r2[c2];
            s4 = n3.call(e5, o3), r2.splice(c2, 1), c2--;
          }
          return s4;
        }), t2.formatArgs.call(e5, r2), (n2.log || t2.log || console.log.bind(console)).apply(e5, r2);
      }
    }
    return n2.namespace = e4, n2.enabled = t2.enabled(e4), n2.useColors = t2.useColors(), n2.color = function(e5) {
      var s4, i3 = 0;
      for (s4 in e5)
        i3 = (i3 << 5) - i3 + e5.charCodeAt(s4), i3 |= 0;
      return t2.colors[Math.abs(i3) % t2.colors.length];
    }(e4), n2.destroy = i2, "function" == typeof t2.init && t2.init(n2), t2.instances.push(n2), n2;
  }
  function i2() {
    var e4 = t2.instances.indexOf(this);
    return -1 !== e4 && (t2.instances.splice(e4, 1), true);
  }
  (t2 = u.exports = s2.debug = s2.default = s2).coerce = function(e4) {
    return e4 instanceof Error ? e4.stack || e4.message : e4;
  }, t2.disable = function() {
    t2.enable("");
  }, t2.enable = function(e4) {
    var s3;
    t2.save(e4), t2.names = [], t2.skips = [];
    var i3 = ("string" == typeof e4 ? e4 : "").split(/[\s,]+/), n2 = i3.length;
    for (s3 = 0; s3 < n2; s3++)
      i3[s3] && ("-" === (e4 = i3[s3].replace(/\*/g, ".*?"))[0] ? t2.skips.push(new RegExp("^" + e4.substr(1) + "$")) : t2.names.push(new RegExp("^" + e4 + "$")));
    for (s3 = 0; s3 < t2.instances.length; s3++) {
      var o2 = t2.instances[s3];
      o2.enabled = t2.enabled(o2.namespace);
    }
  }, t2.enabled = function(e4) {
    if ("*" === e4[e4.length - 1])
      return true;
    var s3, i3;
    for (s3 = 0, i3 = t2.skips.length; s3 < i3; s3++)
      if (t2.skips[s3].test(e4))
        return false;
    for (s3 = 0, i3 = t2.names.length; s3 < i3; s3++)
      if (t2.names[s3].test(e4))
        return true;
    return false;
  }, t2.humanize = f, t2.instances = [], t2.names = [], t2.skips = [], t2.formatters = {};
}(0, u.exports), function(e3, t2) {
  function s2() {
    var e4;
    try {
      e4 = t2.storage.debug;
    } catch (e5) {
    }
    return !e4 && "undefined" != typeof process && "env" in process && (e4 = process.env.DEBUG), e4;
  }
  (t2 = e3.exports = u.exports).log = function() {
    return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }, t2.formatArgs = function(e4) {
    var s3 = this.useColors;
    if (e4[0] = (s3 ? "%c" : "") + this.namespace + (s3 ? " %c" : " ") + e4[0] + (s3 ? "%c " : " ") + "+" + t2.humanize(this.diff), !s3)
      return;
    var i2 = "color: " + this.color;
    e4.splice(1, 0, i2, "color: inherit");
    var n2 = 0, o2 = 0;
    e4[0].replace(/%[a-zA-Z%]/g, function(e5) {
      "%%" !== e5 && (n2++, "%c" === e5 && (o2 = n2));
    }), e4.splice(o2, 0, i2);
  }, t2.save = function(e4) {
    try {
      null == e4 ? t2.storage.removeItem("debug") : t2.storage.debug = e4;
    } catch (e5) {
    }
  }, t2.load = s2, t2.useColors = function() {
    if ("undefined" != typeof window && window.process && "renderer" === window.process.type)
      return true;
    if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }, t2.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
    try {
      return window.localStorage;
    } catch (e4) {
    }
  }(), t2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t2.formatters.j = function(e4) {
    try {
      return JSON.stringify(e4);
    } catch (e5) {
      return "[UnexpectedJSONParseError]: " + e5.message;
    }
  }, t2.enable(s2());
}(c, c.exports);
var y = a;
var E = c.exports("socket.io-client:url");
var v = function(e3, t2) {
  var s2 = e3;
  t2 = t2 || "undefined" != typeof location && location, null == e3 && (e3 = t2.protocol + "//" + t2.host);
  "string" == typeof e3 && ("/" === e3.charAt(0) && (e3 = "/" === e3.charAt(1) ? t2.protocol + e3 : t2.host + e3), /^(https?|wss?):\/\//.test(e3) || (E("protocol-less url %s", e3), e3 = void 0 !== t2 ? t2.protocol + "//" + e3 : "https://" + e3), E("parse %s", e3), s2 = y(e3));
  s2.port || (/^(http|ws)$/.test(s2.protocol) ? s2.port = "80" : /^(http|ws)s$/.test(s2.protocol) && (s2.port = "443"));
  s2.path = s2.path || "/";
  var i2 = -1 !== s2.host.indexOf(":") ? "[" + s2.host + "]" : s2.host;
  return s2.id = s2.protocol + "://" + i2 + ":" + s2.port, s2.href = s2.protocol + "://" + i2 + (t2 && t2.port === s2.port ? "" : ":" + s2.port), s2;
};
var C = {};
var S = { exports: {} };
!function(e3) {
  function t2(e4) {
    if (e4)
      return function(e5) {
        for (var s2 in t2.prototype)
          e5[s2] = t2.prototype[s2];
        return e5;
      }(e4);
  }
  S.exports = t2, t2.prototype.on = t2.prototype.addEventListener = function(e4, t3) {
    return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e4] = this._callbacks["$" + e4] || []).push(t3), this;
  }, t2.prototype.once = function(e4, t3) {
    function s2() {
      this.off(e4, s2), t3.apply(this, arguments);
    }
    return s2.fn = t3, this.on(e4, s2), this;
  }, t2.prototype.off = t2.prototype.removeListener = t2.prototype.removeAllListeners = t2.prototype.removeEventListener = function(e4, t3) {
    if (this._callbacks = this._callbacks || {}, 0 == arguments.length)
      return this._callbacks = {}, this;
    var s2, i2 = this._callbacks["$" + e4];
    if (!i2)
      return this;
    if (1 == arguments.length)
      return delete this._callbacks["$" + e4], this;
    for (var n2 = 0; n2 < i2.length; n2++)
      if ((s2 = i2[n2]) === t3 || s2.fn === t3) {
        i2.splice(n2, 1);
        break;
      }
    return this;
  }, t2.prototype.emit = function(e4) {
    this._callbacks = this._callbacks || {};
    var t3 = [].slice.call(arguments, 1), s2 = this._callbacks["$" + e4];
    if (s2)
      for (var i2 = 0, n2 = (s2 = s2.slice(0)).length; i2 < n2; ++i2)
        s2[i2].apply(this, t3);
    return this;
  }, t2.prototype.listeners = function(e4) {
    return this._callbacks = this._callbacks || {}, this._callbacks["$" + e4] || [];
  }, t2.prototype.hasListeners = function(e4) {
    return !!this.listeners(e4).length;
  };
}();
var b = {}.toString;
var w = Array.isArray || function(e3) {
  return "[object Array]" == b.call(e3);
};
!function(e3) {
  c.exports("socket.io-parser");
  var t2 = S.exports, s2 = w;
  function i2() {
  }
  e3.protocol = 4, e3.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], e3.CONNECT = 0, e3.DISCONNECT = 1, e3.EVENT = 2, e3.ACK = 3, e3.ERROR = 4, e3.BINARY_EVENT = 5, e3.BINARY_ACK = 6, e3.Encoder = i2, e3.Decoder = o2;
  var n2 = e3.ERROR + '"encode error"';
  function o2() {
    this.reconstructor = null;
  }
  function r2(t3) {
    return { type: e3.ERROR, data: "parser error: " + t3 };
  }
  i2.prototype.encode = function(t3, s3) {
    var i3 = function(t4) {
      var s4 = "" + t4.type;
      e3.BINARY_EVENT !== t4.type && e3.BINARY_ACK !== t4.type || (s4 += t4.attachments + "-");
      t4.nsp && "/" !== t4.nsp && (s4 += t4.nsp + ",");
      null != t4.id && (s4 += t4.id);
      if (null != t4.data) {
        var i4 = function(e4) {
          try {
            return JSON.stringify(e4);
          } catch (e5) {
            return false;
          }
        }(t4.data);
        if (false === i4)
          return n2;
        s4 += i4;
      }
      return s4;
    }(t3);
    s3([i3]);
  }, t2(o2.prototype), o2.prototype.add = function(t3) {
    var i3;
    if ("string" != typeof t3)
      throw new Error("Unknown type: " + t3);
    i3 = function(t4) {
      var i4 = 0, n3 = { type: Number(t4.charAt(0)) };
      if (null == e3.types[n3.type])
        return r2("unknown packet type " + n3.type);
      if (e3.BINARY_EVENT === n3.type || e3.BINARY_ACK === n3.type) {
        for (var o3 = ""; "-" !== t4.charAt(++i4) && (o3 += t4.charAt(i4), i4 != t4.length); )
          ;
        if (o3 != Number(o3) || "-" !== t4.charAt(i4))
          throw new Error("Illegal attachments");
        n3.attachments = Number(o3);
      }
      if ("/" === t4.charAt(i4 + 1))
        for (n3.nsp = ""; ++i4; ) {
          if ("," === (c2 = t4.charAt(i4)))
            break;
          if (n3.nsp += c2, i4 === t4.length)
            break;
        }
      else
        n3.nsp = "/";
      var a2 = t4.charAt(i4 + 1);
      if ("" !== a2 && Number(a2) == a2) {
        for (n3.id = ""; ++i4; ) {
          var c2;
          if (null == (c2 = t4.charAt(i4)) || Number(c2) != c2) {
            --i4;
            break;
          }
          if (n3.id += t4.charAt(i4), i4 === t4.length)
            break;
        }
        n3.id = Number(n3.id);
      }
      if (t4.charAt(++i4)) {
        var u2 = function(e4) {
          try {
            return JSON.parse(e4);
          } catch (e5) {
            return false;
          }
        }(t4.substr(i4));
        if (!(false !== u2 && (n3.type === e3.ERROR || s2(u2))))
          return r2("invalid payload");
        n3.data = u2;
      }
      return n3;
    }(t3), this.emit("decoded", i3);
  }, o2.prototype.destroy = function() {
    this.reconstructor && this.reconstructor.finishedReconstruction();
  };
}(C);
var I = { exports: {} };
var M = {};
var A = {};
var T = Object.keys || function(e3) {
  var t2 = [], s2 = Object.prototype.hasOwnProperty;
  for (var i2 in e3)
    s2.call(e3, i2) && t2.push(i2);
  return t2;
};
var N = w;
var R = Object.prototype.toString;
var O = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === R.call(Blob);
var _ = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === R.call(File);
var P = function e2(t2) {
  if (!t2 || "object" != typeof t2)
    return false;
  if (N(t2)) {
    for (var s2 = 0, i2 = t2.length; s2 < i2; s2++)
      if (e2(t2[s2]))
        return true;
    return false;
  }
  if ("function" == typeof Buffer && Buffer.isBuffer && Buffer.isBuffer(t2) || "function" == typeof ArrayBuffer && t2 instanceof ArrayBuffer || O && t2 instanceof Blob || _ && t2 instanceof File)
    return true;
  if (t2.toJSON && "function" == typeof t2.toJSON && 1 === arguments.length)
    return e2(t2.toJSON(), true);
  for (var n2 in t2)
    if (Object.prototype.hasOwnProperty.call(t2, n2) && e2(t2[n2]))
      return true;
  return false;
};
var k = function(e3, t2, s2) {
  var i2 = false;
  return s2 = s2 || D, n2.count = e3, 0 === e3 ? t2() : n2;
  function n2(e4, o2) {
    if (n2.count <= 0)
      throw new Error("after called too many times");
    --n2.count, e4 ? (i2 = true, t2(e4), t2 = s2) : 0 !== n2.count || i2 || t2(null, o2);
  }
};
function D() {
}
var x;
var F;
var U;
var L = String.fromCharCode;
function G(e3) {
  for (var t2, s2, i2 = [], n2 = 0, o2 = e3.length; n2 < o2; )
    (t2 = e3.charCodeAt(n2++)) >= 55296 && t2 <= 56319 && n2 < o2 ? 56320 == (64512 & (s2 = e3.charCodeAt(n2++))) ? i2.push(((1023 & t2) << 10) + (1023 & s2) + 65536) : (i2.push(t2), n2--) : i2.push(t2);
  return i2;
}
function B(e3, t2) {
  if (e3 >= 55296 && e3 <= 57343) {
    if (t2)
      throw Error("Lone surrogate U+" + e3.toString(16).toUpperCase() + " is not a scalar value");
    return false;
  }
  return true;
}
function q(e3, t2) {
  return L(e3 >> t2 & 63 | 128);
}
function j(e3, t2) {
  if (0 == (4294967168 & e3))
    return L(e3);
  var s2 = "";
  return 0 == (4294965248 & e3) ? s2 = L(e3 >> 6 & 31 | 192) : 0 == (4294901760 & e3) ? (B(e3, t2) || (e3 = 65533), s2 = L(e3 >> 12 & 15 | 224), s2 += q(e3, 6)) : 0 == (4292870144 & e3) && (s2 = L(e3 >> 18 & 7 | 240), s2 += q(e3, 12), s2 += q(e3, 6)), s2 += L(63 & e3 | 128);
}
function V() {
  if (U >= F)
    throw Error("Invalid byte index");
  var e3 = 255 & x[U];
  if (U++, 128 == (192 & e3))
    return 63 & e3;
  throw Error("Invalid continuation byte");
}
function H(e3) {
  var t2, s2;
  if (U > F)
    throw Error("Invalid byte index");
  if (U == F)
    return false;
  if (t2 = 255 & x[U], U++, 0 == (128 & t2))
    return t2;
  if (192 == (224 & t2)) {
    if ((s2 = (31 & t2) << 6 | V()) >= 128)
      return s2;
    throw Error("Invalid continuation byte");
  }
  if (224 == (240 & t2)) {
    if ((s2 = (15 & t2) << 12 | V() << 6 | V()) >= 2048)
      return B(s2, e3) ? s2 : 65533;
    throw Error("Invalid continuation byte");
  }
  if (240 == (248 & t2) && (s2 = (7 & t2) << 18 | V() << 12 | V() << 6 | V()) >= 65536 && s2 <= 1114111)
    return s2;
  throw Error("Invalid UTF-8 detected");
}
var W = { version: "2.1.2", encode: function(e3, t2) {
  for (var s2 = false !== (t2 = t2 || {}).strict, i2 = G(e3), n2 = i2.length, o2 = -1, r2 = ""; ++o2 < n2; )
    r2 += j(i2[o2], s2);
  return r2;
}, decode: function(e3, t2) {
  var s2 = false !== (t2 = t2 || {}).strict;
  x = G(e3), F = x.length, U = 0;
  for (var i2, n2 = []; false !== (i2 = H(s2)); )
    n2.push(i2);
  return function(e4) {
    for (var t3, s3 = e4.length, i3 = -1, n3 = ""; ++i3 < s3; )
      (t3 = e4[i3]) > 65535 && (n3 += L((t3 -= 65536) >>> 10 & 1023 | 55296), t3 = 56320 | 1023 & t3), n3 += L(t3);
    return n3;
  }(n2);
} };
var z = void 0 !== z ? z : "undefined" != typeof WebKitBlobBuilder ? WebKitBlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder && MozBlobBuilder;
var X = function() {
  try {
    return 2 === new Blob(["hi"]).size;
  } catch (e3) {
    return false;
  }
}();
var J = X && function() {
  try {
    return 2 === new Blob([new Uint8Array([1, 2])]).size;
  } catch (e3) {
    return false;
  }
}();
var Y = z && z.prototype.append && z.prototype.getBlob;
function Q(e3) {
  return e3.map(function(e4) {
    if (e4.buffer instanceof ArrayBuffer) {
      var t2 = e4.buffer;
      if (e4.byteLength !== t2.byteLength) {
        var s2 = new Uint8Array(e4.byteLength);
        s2.set(new Uint8Array(t2, e4.byteOffset, e4.byteLength)), t2 = s2.buffer;
      }
      return t2;
    }
    return e4;
  });
}
function $(e3, t2) {
  t2 = t2 || {};
  var s2 = new z();
  return Q(e3).forEach(function(e4) {
    s2.append(e4);
  }), t2.type ? s2.getBlob(t2.type) : s2.getBlob();
}
function K(e3, t2) {
  return new Blob(Q(e3), t2 || {});
}
"undefined" != typeof Blob && ($.prototype = Blob.prototype, K.prototype = Blob.prototype);
var Z = X ? J ? Blob : K : Y ? $ : void 0;
!function(e3) {
  var t2 = T, s2 = P, i2 = k, n2 = W;
  "undefined" != typeof navigator && /Android/i.test(navigator.userAgent), "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent), e3.protocol = 3;
  var o2 = e3.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 }, r2 = t2(o2), a2 = { type: "error", data: "parser error" }, c2 = Z;
  e3.encodePacket = function(e4, t3, s3, i3) {
    "function" == typeof t3 && (i3 = t3, t3 = false), "function" == typeof s3 && (i3 = s3, s3 = null), void 0 === e4.data || e4.data.buffer || e4.data;
    var r3 = o2[e4.type];
    return void 0 !== e4.data && (r3 += s3 ? n2.encode(String(e4.data), { strict: false }) : String(e4.data)), i3("" + r3);
  }, e3.decodePacket = function(e4, t3, s3) {
    if (void 0 === e4)
      return a2;
    if ("string" == typeof e4) {
      if (s3 && false === (e4 = function(e5) {
        try {
          e5 = n2.decode(e5, { strict: false });
        } catch (e6) {
          return false;
        }
        return e5;
      }(e4)))
        return a2;
      var i3 = e4.charAt(0);
      return Number(i3) == i3 && r2[i3] ? e4.length > 1 ? { type: r2[i3], data: e4.substring(1) } : { type: r2[i3] } : a2;
    }
    i3 = new Uint8Array(e4)[0];
    var o3 = sliceBuffer(e4, 1);
    return c2 && "blob" === t3 && (o3 = new c2([o3])), { type: r2[i3], data: o3 };
  }, e3.encodePayload = function(t3, n3, o3) {
    "function" == typeof n3 && (o3 = n3, n3 = null);
    var r3 = s2(t3);
    if (!t3.length)
      return o3("0:");
    !function(e4, t4, s3) {
      for (var n4 = new Array(e4.length), o4 = i2(e4.length, s3), r4 = function(e5, s4, i3) {
        t4(s4, function(t5, s5) {
          n4[e5] = s5, i3(t5, n4);
        });
      }, a3 = 0; a3 < e4.length; a3++)
        r4(a3, e4[a3], o4);
    }(t3, function(t4, s3) {
      e3.encodePacket(t4, !!r3 && n3, true, function(e4) {
        s3(null, function(e5) {
          return e5.length + ":" + e5;
        }(e4));
      });
    }, function(e4, t4) {
      return o3(t4.join(""));
    });
  }, e3.decodePayload = function(t3, s3, i3) {
    var n3;
    if ("function" == typeof s3 && (i3 = s3, s3 = null), "" === t3)
      return i3(a2, 0, 1);
    for (var o3, r3, c3 = "", u2 = 0, l2 = t3.length; u2 < l2; u2++) {
      var d2 = t3.charAt(u2);
      if (":" === d2) {
        if ("" === c3 || c3 != (o3 = Number(c3)))
          return i3(a2, 0, 1);
        if (c3 != (r3 = t3.substr(u2 + 1, o3)).length)
          return i3(a2, 0, 1);
        if (r3.length) {
          if (n3 = e3.decodePacket(r3, s3, true), a2.type === n3.type && a2.data === n3.data)
            return i3(a2, 0, 1);
          if (false === i3(n3, u2 + o3, l2))
            return;
        }
        u2 += o3, c3 = "";
      } else
        c3 += d2;
    }
    return "" !== c3 ? i3(a2, 0, 1) : void 0;
  };
}(A);
var ee = A;
var te = se;
function se(e3) {
  this.path = e3.path, this.hostname = e3.hostname, this.port = e3.port, this.secure = e3.secure, this.query = e3.query, this.timestampParam = e3.timestampParam, this.timestampRequests = e3.timestampRequests, this.readyState = "", this.agent = e3.agent || false, this.socket = e3.socket, this.enablesXDR = e3.enablesXDR, this.pfx = e3.pfx, this.key = e3.key, this.passphrase = e3.passphrase, this.cert = e3.cert, this.ca = e3.ca, this.ciphers = e3.ciphers, this.rejectUnauthorized = e3.rejectUnauthorized, this.forceNode = e3.forceNode, this.isReactNative = e3.isReactNative, this.extraHeaders = e3.extraHeaders, this.localAddress = e3.localAddress;
}
(0, S.exports)(se.prototype), se.prototype.onError = function(e3, t2) {
  var s2 = new Error(e3);
  return s2.type = "TransportError", s2.description = t2, this.emit("error", s2), this;
}, se.prototype.open = function() {
  return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this;
}, se.prototype.close = function() {
  return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this;
}, se.prototype.send = function(e3) {
  if ("open" !== this.readyState)
    throw new Error("Transport not open");
  this.write(e3);
}, se.prototype.onOpen = function() {
  this.readyState = "open", this.writable = true, this.emit("open");
}, se.prototype.onData = function(e3) {
  var t2 = ee.decodePacket(e3, this.socket.binaryType);
  this.onPacket(t2);
}, se.prototype.onPacket = function(e3) {
  this.emit("packet", e3);
}, se.prototype.onClose = function() {
  this.readyState = "closed", this.emit("close");
};
var ie;
var ne = { encode: function(e3) {
  var t2 = "";
  for (var s2 in e3)
    e3.hasOwnProperty(s2) && (t2.length && (t2 += "&"), t2 += encodeURIComponent(s2) + "=" + encodeURIComponent(e3[s2]));
  return t2;
}, decode: function(e3) {
  for (var t2 = {}, s2 = e3.split("&"), i2 = 0, n2 = s2.length; i2 < n2; i2++) {
    var o2 = s2[i2].split("=");
    t2[decodeURIComponent(o2[0])] = decodeURIComponent(o2[1]);
  }
  return t2;
} };
var oe = function(e3, t2) {
  var s2 = function() {
  };
  s2.prototype = t2.prototype, e3.prototype = new s2(), e3.prototype.constructor = e3;
};
var re = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var ae = 64;
var ce = {};
var ue = 0;
var le = 0;
function de(e3) {
  var t2 = "";
  do {
    t2 = re[e3 % ae] + t2, e3 = Math.floor(e3 / ae);
  } while (e3 > 0);
  return t2;
}
function he() {
  var e3 = de(+/* @__PURE__ */ new Date());
  return e3 !== ie ? (ue = 0, ie = e3) : e3 + "." + de(ue++);
}
for (; le < ae; le++)
  ce[re[le]] = le;
he.encode = de, he.decode = function(e3) {
  var t2 = 0;
  for (le = 0; le < e3.length; le++)
    t2 = t2 * ae + ce[e3.charAt(le)];
  return t2;
};
var pe = he;
var me = { exports: {} };
var fe = { exports: {} };
var ge = 1e3;
var ye = 60 * ge;
var Ee = 60 * ye;
var ve = 24 * Ee;
var Ce = 365.25 * ve;
var Se = function(e3, t2) {
  t2 = t2 || {};
  var s2 = typeof e3;
  if ("string" === s2 && e3.length > 0)
    return function(e4) {
      if (e4 = String(e4), e4.length > 100)
        return;
      var t3 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e4);
      if (!t3)
        return;
      var s3 = parseFloat(t3[1]);
      switch ((t3[2] || "ms").toLowerCase()) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return s3 * Ce;
        case "days":
        case "day":
        case "d":
          return s3 * ve;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return s3 * Ee;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return s3 * ye;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return s3 * ge;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return s3;
        default:
          return;
      }
    }(e3);
  if ("number" === s2 && false === isNaN(e3))
    return t2.long ? function(e4) {
      return be(e4, ve, "day") || be(e4, Ee, "hour") || be(e4, ye, "minute") || be(e4, ge, "second") || e4 + " ms";
    }(e3) : function(e4) {
      if (e4 >= ve)
        return Math.round(e4 / ve) + "d";
      if (e4 >= Ee)
        return Math.round(e4 / Ee) + "h";
      if (e4 >= ye)
        return Math.round(e4 / ye) + "m";
      if (e4 >= ge)
        return Math.round(e4 / ge) + "s";
      return e4 + "ms";
    }(e3);
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e3));
};
function be(e3, t2, s2) {
  if (!(e3 < t2))
    return e3 < 1.5 * t2 ? Math.floor(e3 / t2) + " " + s2 : Math.ceil(e3 / t2) + " " + s2 + "s";
}
!function(e3, t2) {
  function s2(e4) {
    var s3;
    function n2() {
      if (n2.enabled) {
        var e5 = n2, i3 = +/* @__PURE__ */ new Date(), o2 = i3 - (s3 || i3);
        e5.diff = o2, e5.prev = s3, e5.curr = i3, s3 = i3;
        for (var r2 = new Array(arguments.length), a2 = 0; a2 < r2.length; a2++)
          r2[a2] = arguments[a2];
        r2[0] = t2.coerce(r2[0]), "string" != typeof r2[0] && r2.unshift("%O");
        var c2 = 0;
        r2[0] = r2[0].replace(/%([a-zA-Z%])/g, function(s4, i4) {
          if ("%%" === s4)
            return s4;
          c2++;
          var n3 = t2.formatters[i4];
          if ("function" == typeof n3) {
            var o3 = r2[c2];
            s4 = n3.call(e5, o3), r2.splice(c2, 1), c2--;
          }
          return s4;
        }), t2.formatArgs.call(e5, r2), (n2.log || t2.log || console.log.bind(console)).apply(e5, r2);
      }
    }
    return n2.namespace = e4, n2.enabled = t2.enabled(e4), n2.useColors = t2.useColors(), n2.color = function(e5) {
      var s4, i3 = 0;
      for (s4 in e5)
        i3 = (i3 << 5) - i3 + e5.charCodeAt(s4), i3 |= 0;
      return t2.colors[Math.abs(i3) % t2.colors.length];
    }(e4), n2.destroy = i2, "function" == typeof t2.init && t2.init(n2), t2.instances.push(n2), n2;
  }
  function i2() {
    var e4 = t2.instances.indexOf(this);
    return -1 !== e4 && (t2.instances.splice(e4, 1), true);
  }
  (t2 = fe.exports = s2.debug = s2.default = s2).coerce = function(e4) {
    return e4 instanceof Error ? e4.stack || e4.message : e4;
  }, t2.disable = function() {
    t2.enable("");
  }, t2.enable = function(e4) {
    var s3;
    t2.save(e4), t2.names = [], t2.skips = [];
    var i3 = ("string" == typeof e4 ? e4 : "").split(/[\s,]+/), n2 = i3.length;
    for (s3 = 0; s3 < n2; s3++)
      i3[s3] && ("-" === (e4 = i3[s3].replace(/\*/g, ".*?"))[0] ? t2.skips.push(new RegExp("^" + e4.substr(1) + "$")) : t2.names.push(new RegExp("^" + e4 + "$")));
    for (s3 = 0; s3 < t2.instances.length; s3++) {
      var o2 = t2.instances[s3];
      o2.enabled = t2.enabled(o2.namespace);
    }
  }, t2.enabled = function(e4) {
    if ("*" === e4[e4.length - 1])
      return true;
    var s3, i3;
    for (s3 = 0, i3 = t2.skips.length; s3 < i3; s3++)
      if (t2.skips[s3].test(e4))
        return false;
    for (s3 = 0, i3 = t2.names.length; s3 < i3; s3++)
      if (t2.names[s3].test(e4))
        return true;
    return false;
  }, t2.humanize = Se, t2.instances = [], t2.names = [], t2.skips = [], t2.formatters = {};
}(0, fe.exports), function(e3, t2) {
  function s2() {
    var e4;
    try {
      e4 = t2.storage.debug;
    } catch (e5) {
    }
    return !e4 && "undefined" != typeof process && "env" in process && (e4 = process.env.DEBUG), e4;
  }
  (t2 = e3.exports = fe.exports).log = function() {
    return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }, t2.formatArgs = function(e4) {
    var s3 = this.useColors;
    if (e4[0] = (s3 ? "%c" : "") + this.namespace + (s3 ? " %c" : " ") + e4[0] + (s3 ? "%c " : " ") + "+" + t2.humanize(this.diff), !s3)
      return;
    var i2 = "color: " + this.color;
    e4.splice(1, 0, i2, "color: inherit");
    var n2 = 0, o2 = 0;
    e4[0].replace(/%[a-zA-Z%]/g, function(e5) {
      "%%" !== e5 && (n2++, "%c" === e5 && (o2 = n2));
    }), e4.splice(o2, 0, i2);
  }, t2.save = function(e4) {
    try {
      null == e4 ? t2.storage.removeItem("debug") : t2.storage.debug = e4;
    } catch (e5) {
    }
  }, t2.load = s2, t2.useColors = function() {
    if ("undefined" != typeof window && window.process && "renderer" === window.process.type)
      return true;
    if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }, t2.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
    try {
      return window.localStorage;
    } catch (e4) {
    }
  }(), t2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t2.formatters.j = function(e4) {
    try {
      return JSON.stringify(e4);
    } catch (e5) {
      return "[UnexpectedJSONParseError]: " + e5.message;
    }
  }, t2.enable(s2());
}(me, me.exports);
var we = { exports: {} };
try {
  we.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
} catch (e3) {
  we.exports = false;
}
var Ie = we.exports;
var Me = function(e3) {
  var t2 = e3.xdomain, s2 = e3.xscheme, i2 = e3.enablesXDR;
  try {
    if ("undefined" != typeof XMLHttpRequest && (!t2 || Ie))
      return new XMLHttpRequest();
  } catch (e4) {
  }
  try {
    if ("undefined" != typeof XDomainRequest && !s2 && i2)
      return new XDomainRequest();
  } catch (e4) {
  }
  if (!t2)
    try {
      return new self[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e4) {
    }
};
var Ae = te;
var Te = ne;
var Ne = A;
var Re = oe;
var Oe = pe;
var _e = me.exports("engine.io-client:polling");
var Pe = De;
var ke = null != new Me({ xdomain: false }).responseType;
function De(e3) {
  var t2 = e3 && e3.forceBase64;
  ke && !t2 || (this.supportsBinary = false), Ae.call(this, e3);
}
Re(De, Ae), De.prototype.name = "polling", De.prototype.doOpen = function() {
  this.poll();
}, De.prototype.pause = function(e3) {
  var t2 = this;
  function s2() {
    _e("paused"), t2.readyState = "paused", e3();
  }
  if (this.readyState = "pausing", this.polling || !this.writable) {
    var i2 = 0;
    this.polling && (_e("we are currently polling - waiting to pause"), i2++, this.once("pollComplete", function() {
      _e("pre-pause polling complete"), --i2 || s2();
    })), this.writable || (_e("we are currently writing - waiting to pause"), i2++, this.once("drain", function() {
      _e("pre-pause writing complete"), --i2 || s2();
    }));
  } else
    s2();
}, De.prototype.poll = function() {
  _e("polling"), this.polling = true, this.doPoll(), this.emit("poll");
}, De.prototype.onData = function(e3) {
  var t2 = this;
  _e("polling got data %s", e3);
  Ne.decodePayload(e3, this.socket.binaryType, function(e4, s2, i2) {
    if ("opening" === t2.readyState && t2.onOpen(), "close" === e4.type)
      return t2.onClose(), false;
    t2.onPacket(e4);
  }), "closed" !== this.readyState && (this.polling = false, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : _e('ignoring poll - transport state "%s"', this.readyState));
}, De.prototype.doClose = function() {
  var e3 = this;
  function t2() {
    _e("writing close packet"), e3.write([{ type: "close" }]);
  }
  "open" === this.readyState ? (_e("transport open - closing"), t2()) : (_e("transport not open - deferring close"), this.once("open", t2));
}, De.prototype.write = function(e3) {
  var t2 = this;
  this.writable = false;
  var s2 = function() {
    t2.writable = true, t2.emit("drain");
  };
  Ne.encodePayload(e3, this.supportsBinary, function(e4) {
    t2.doWrite(e4, s2);
  });
}, De.prototype.uri = function() {
  var e3 = this.query || {}, t2 = this.secure ? "https" : "http", s2 = "";
  return false !== this.timestampRequests && (e3[this.timestampParam] = Oe()), this.supportsBinary || e3.sid || (e3.b64 = 1), e3 = Te.encode(e3), this.port && ("https" === t2 && 443 !== Number(this.port) || "http" === t2 && 80 !== Number(this.port)) && (s2 = ":" + this.port), e3.length && (e3 = "?" + e3), t2 + "://" + (-1 !== this.hostname.indexOf(":") ? "[" + this.hostname + "]" : this.hostname) + s2 + this.path + e3;
};
var xe;
var Fe = Pe;
var Ue = je;
var Le = /\n/g;
var Ge = /\\n/g;
function Be() {
}
function qe() {
  return "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== s ? s : {};
}
function je(e3) {
  if (Fe.call(this, e3), this.query = this.query || {}, !xe) {
    var t2 = qe();
    xe = t2.___eio = t2.___eio || [];
  }
  this.index = xe.length;
  var s2 = this;
  xe.push(function(e4) {
    s2.onData(e4);
  }), this.query.j = this.index, "function" == typeof addEventListener && addEventListener("beforeunload", function() {
    s2.script && (s2.script.onerror = Be);
  }, false);
}
oe(je, Fe), je.prototype.supportsBinary = false, je.prototype.doClose = function() {
  this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), Fe.prototype.doClose.call(this);
}, je.prototype.doPoll = function() {
  var e3 = this, t2 = document.createElement("script");
  this.script && (this.script.parentNode.removeChild(this.script), this.script = null), t2.async = true, t2.src = this.uri(), t2.onerror = function(t3) {
    e3.onError("jsonp poll error", t3);
  };
  var s2 = document.getElementsByTagName("script")[0];
  s2 ? s2.parentNode.insertBefore(t2, s2) : (document.head || document.body).appendChild(t2), this.script = t2, "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout(function() {
    var e4 = document.createElement("iframe");
    document.body.appendChild(e4), document.body.removeChild(e4);
  }, 100);
}, je.prototype.doWrite = function(e3, t2) {
  var s2 = this;
  if (!this.form) {
    var i2, n2 = document.createElement("form"), o2 = document.createElement("textarea"), r2 = this.iframeId = "eio_iframe_" + this.index;
    n2.className = "socketio", n2.style.position = "absolute", n2.style.top = "-1000px", n2.style.left = "-1000px", n2.target = r2, n2.method = "POST", n2.setAttribute("accept-charset", "utf-8"), o2.name = "d", n2.appendChild(o2), document.body.appendChild(n2), this.form = n2, this.area = o2;
  }
  function a2() {
    c2(), t2();
  }
  function c2() {
    if (s2.iframe)
      try {
        s2.form.removeChild(s2.iframe);
      } catch (e5) {
        s2.onError("jsonp polling iframe removal error", e5);
      }
    try {
      var e4 = '<iframe src="javascript:0" name="' + s2.iframeId + '">';
      i2 = document.createElement(e4);
    } catch (e5) {
      (i2 = document.createElement("iframe")).name = s2.iframeId, i2.src = "javascript:0";
    }
    i2.id = s2.iframeId, s2.form.appendChild(i2), s2.iframe = i2;
  }
  this.form.action = this.uri(), c2(), e3 = e3.replace(Ge, "\\\n"), this.area.value = e3.replace(Le, "\\n");
  try {
    this.form.submit();
  } catch (e4) {
  }
  this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
    "complete" === s2.iframe.readyState && a2();
  } : this.iframe.onload = a2;
};
var Ve;
var He;
var We = te;
var ze = A;
var Xe = ne;
var Je = oe;
var Ye = pe;
var Qe = me.exports("engine.io-client:websocket");
("undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket) && ("undefined" != typeof WebSocket ? Ve = WebSocket : "undefined" != typeof self && (Ve = self.WebSocket || self.MozWebSocket));
var $e = Ve || He;
("undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket) && "undefined" == typeof GameGlobal || ($e = function(e3) {
  var t2 = this;
  if (t2.onopen = function() {
  }, t2.onclose = function() {
  }, t2.onmessage = function(e4) {
  }, t2.onerror = function(e4) {
  }, "object" == typeof tt && tt.getSystemInfo) {
    let s3 = tt.connectSocket({ url: e3 });
    t2.send = function(e4) {
      s3.send({ data: e4 });
    }, t2.close = function() {
      s3.close();
    }, s3.onOpen(function() {
      t2.onopen();
    }), s3.onError(function(e4) {
      t2.onerror(e4);
    }), s3.onMessage(function(e4) {
      t2.onmessage(e4);
    }), s3.onClose(function() {
      t2.onclose();
    });
  } else if ("undefined" != typeof uni)
    if ("undefined" != typeof my)
      my.connectSocket({ url: e3 }), t2.send = function(e4) {
        my.sendSocketMessage({ data: e4 });
      }, t2.close = function(e4) {
        my.closeSocket();
      }, my.onSocketOpen(function(e4) {
        t2.onopen();
      }), my.onSocketError(function(e4) {
        t2.onerror(e4);
      }), my.onSocketMessage(function(e4) {
        t2.onmessage(e4);
      }), my.onSocketClose((e4) => {
        t2.onclose(e4);
      });
    else {
      var s2 = uni.connectSocket({ url: e3, complete: () => {
      } });
      t2.send = function(e4) {
        s2.send({ data: e4 });
      }, t2.close = function() {
        s2.close();
      }, s2.onOpen(function(e4) {
        t2.onopen();
      }), s2.onError(function(e4) {
        t2.onerror(e4);
      }), s2.onMessage(function(e4) {
        t2.onmessage(e4);
      }), s2.onClose(function(e4) {
        t2.onclose();
      });
    }
  else {
    var i2 = wx.connectSocket({ url: e3 });
    t2.send = function(e4) {
      i2.send({ data: e4 });
    }, t2.close = function(e4) {
      i2.close({ code: 1e3 });
    }, i2.onOpen(function() {
      t2.onopen();
    }), i2.onError(function(e4) {
      t2.onerror(e4);
    }), i2.onMessage(function(e4) {
      t2.onmessage(e4);
    }), i2.onClose(function(e4) {
      t2.onclose(e4);
    });
  }
});
var Ke = Ze;
function Ze(e3) {
  e3 && e3.forceBase64 && (this.supportsBinary = false), ("undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket) && (this.perMessageDeflate = e3.perMessageDeflate, this.usingBrowserWebSocket = Ve && !e3.forceNode, this.protocols = e3.protocols, this.usingBrowserWebSocket || ($e = He)), We.call(this, e3);
}
Je(Ze, We), Ze.prototype.name = "websocket", Ze.prototype.supportsBinary = false, Ze.prototype.doOpen = function() {
  if (this.check()) {
    var e3, t2, s2 = this.uri();
    ("undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket) && (e3 = this.protocols), (t2 = "undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket ? { agent: this.agent, perMessageDeflate: this.perMessageDeflate } : { agent: this.agent }).pfx = this.pfx, t2.key = this.key, t2.passphrase = this.passphrase, t2.cert = this.cert, t2.ca = this.ca, t2.ciphers = this.ciphers, t2.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (t2.headers = this.extraHeaders), this.localAddress && (t2.localAddress = this.localAddress);
    try {
      "undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket ? this.ws = this.usingBrowserWebSocket && !this.isReactNative ? e3 ? new $e(s2, e3) : new $e(s2) : new $e(s2, e3, t2) : this.ws = new $e(s2);
    } catch (e4) {
      return this.emit("error", e4);
    }
    void 0 === this.ws.binaryType && (this.supportsBinary = false), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = true, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners();
  }
}, Ze.prototype.addEventListeners = function() {
  var e3 = this;
  this.ws.onopen = function() {
    e3.onOpen();
  }, this.ws.onclose = function() {
    e3.onClose();
  }, this.ws.onmessage = function(t2) {
    e3.onData(t2.data);
  }, this.ws.onerror = function(t2) {
    e3.onError("websocket error", t2);
  };
}, Ze.prototype.write = function(e3) {
  var t2 = this;
  this.writable = false;
  for (var s2 = e3.length, i2 = 0, n2 = s2; i2 < n2; i2++)
    !function(e4) {
      ze.encodePacket(e4, t2.supportsBinary, function(i3) {
        if ("undefined" == typeof uni && "undefined" == typeof wx || "undefined" != typeof WebSocket) {
          if (!t2.usingBrowserWebSocket) {
            var n3 = {};
            if (e4.options && (n3.compress = e4.options.compress), t2.perMessageDeflate)
              ("string" == typeof i3 ? Buffer.byteLength(i3) : i3.length) < t2.perMessageDeflate.threshold && (n3.compress = false);
          }
          try {
            t2.usingBrowserWebSocket ? t2.ws.send(i3) : t2.ws.send(i3, n3);
          } catch (e5) {
            Qe("websocket closed before onclose event");
          }
        } else
          try {
            t2.ws.send(i3);
          } catch (e5) {
            Qe("websocket closed before onclose event");
          }
        --s2 || o2();
      });
    }(e3[i2]);
  function o2() {
    t2.emit("flush"), setTimeout(function() {
      t2.writable = true, t2.emit("drain");
    }, 0);
  }
}, Ze.prototype.onClose = function() {
  We.prototype.onClose.call(this);
}, Ze.prototype.doClose = function() {
  void 0 !== this.ws && this.ws.close();
}, Ze.prototype.uri = function() {
  var e3 = this.query || {}, t2 = this.secure ? "wss" : "ws", s2 = "";
  return this.port && ("wss" === t2 && 443 !== Number(this.port) || "ws" === t2 && 80 !== Number(this.port)) && (s2 = ":" + this.port), this.timestampRequests && (e3[this.timestampParam] = Ye()), this.supportsBinary || (e3.b64 = 1), (e3 = Xe.encode(e3)).length && (e3 = "?" + e3), t2 + "://" + (-1 !== this.hostname.indexOf(":") ? "[" + this.hostname + "]" : this.hostname) + s2 + this.path + e3;
}, Ze.prototype.check = function() {
  return !(!$e || "__initialize" in $e && this.name === Ze.prototype.name);
};
var et = Ue;
var st = Ke;
M.polling = function(e3) {
  var t2 = false, s2 = false;
  if (e3.jsonp, "undefined" != typeof location) {
    var i2 = "https:" === location.protocol, n2 = location.port;
    n2 || (n2 = i2 ? 443 : 80), t2 = e3.hostname !== location.hostname || n2 !== e3.port, s2 = e3.secure !== i2;
  }
  return e3.xdomain = t2, e3.xscheme = s2, new et(e3);
}, M.websocket = st;
var it = [].indexOf;
var nt = function(e3, t2) {
  if (it)
    return e3.indexOf(t2);
  for (var s2 = 0; s2 < e3.length; ++s2)
    if (e3[s2] === t2)
      return s2;
  return -1;
};
var ot = M;
var rt = S.exports;
var at = me.exports("engine.io-client:socket");
var ct = nt;
var ut = A;
var lt = a;
var dt = ne;
var ht = pt;
function pt(e3, t2) {
  if (!(this instanceof pt))
    return new pt(e3, t2);
  t2 = t2 || {}, e3 && "object" == typeof e3 && (t2 = e3, e3 = null), e3 ? (e3 = lt(e3), t2.hostname = e3.host, t2.secure = "https" === e3.protocol || "wss" === e3.protocol, t2.port = e3.port, e3.query && (t2.query = e3.query)) : t2.host && (t2.hostname = lt(t2.host).host), this.secure = null != t2.secure ? t2.secure : "undefined" != typeof location && "https:" === location.protocol, t2.hostname && !t2.port && (t2.port = this.secure ? "443" : "80"), this.agent = t2.agent || false, this.hostname = t2.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = t2.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? 443 : 80), this.query = t2.query || {}, "string" == typeof this.query && (this.query = dt.decode(this.query)), this.upgrade = false !== t2.upgrade, this.path = (t2.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!t2.forceJSONP, this.jsonp = false !== t2.jsonp, this.forceBase64 = !!t2.forceBase64, this.enablesXDR = !!t2.enablesXDR, this.timestampParam = t2.timestampParam || "t", this.timestampRequests = t2.timestampRequests, this.transports = t2.transports || ["polling", "websocket"], this.transportOptions = t2.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = t2.policyPort || 843, this.rememberUpgrade = t2.rememberUpgrade || false, this.binaryType = null, this.onlyBinaryUpgrades = t2.onlyBinaryUpgrades, this.perMessageDeflate = false !== t2.perMessageDeflate && (t2.perMessageDeflate || {}), true === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = t2.pfx || null, this.key = t2.key || null, this.passphrase = t2.passphrase || null, this.cert = t2.cert || null, this.ca = t2.ca || null, this.ciphers = t2.ciphers || null, this.rejectUnauthorized = void 0 === t2.rejectUnauthorized || t2.rejectUnauthorized, this.forceNode = !!t2.forceNode, this.isReactNative = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), ("undefined" == typeof self || this.isReactNative) && (t2.extraHeaders && Object.keys(t2.extraHeaders).length > 0 && (this.extraHeaders = t2.extraHeaders), t2.localAddress && (this.localAddress = t2.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open();
}
pt.priorWebsocketSuccess = false, rt(pt.prototype), pt.protocol = ut.protocol, pt.Socket = pt, pt.Transport = te, pt.transports = M, pt.parser = A, pt.prototype.createTransport = function(e3) {
  at('creating transport "%s"', e3);
  var t2 = function(e4) {
    var t3 = {};
    for (var s3 in e4)
      e4.hasOwnProperty(s3) && (t3[s3] = e4[s3]);
    return t3;
  }(this.query);
  t2.EIO = ut.protocol, t2.transport = e3;
  var s2 = this.transportOptions[e3] || {};
  return this.id && (t2.sid = this.id), new ot[e3]({ query: t2, socket: this, agent: s2.agent || this.agent, hostname: s2.hostname || this.hostname, port: s2.port || this.port, secure: s2.secure || this.secure, path: s2.path || this.path, forceJSONP: s2.forceJSONP || this.forceJSONP, jsonp: s2.jsonp || this.jsonp, forceBase64: s2.forceBase64 || this.forceBase64, enablesXDR: s2.enablesXDR || this.enablesXDR, timestampRequests: s2.timestampRequests || this.timestampRequests, timestampParam: s2.timestampParam || this.timestampParam, policyPort: s2.policyPort || this.policyPort, pfx: s2.pfx || this.pfx, key: s2.key || this.key, passphrase: s2.passphrase || this.passphrase, cert: s2.cert || this.cert, ca: s2.ca || this.ca, ciphers: s2.ciphers || this.ciphers, rejectUnauthorized: s2.rejectUnauthorized || this.rejectUnauthorized, perMessageDeflate: s2.perMessageDeflate || this.perMessageDeflate, extraHeaders: s2.extraHeaders || this.extraHeaders, forceNode: s2.forceNode || this.forceNode, localAddress: s2.localAddress || this.localAddress, requestTimeout: s2.requestTimeout || this.requestTimeout, protocols: s2.protocols || void 0, isReactNative: this.isReactNative });
}, pt.prototype.open = function() {
  var e3;
  if (this.rememberUpgrade && pt.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket"))
    e3 = "websocket";
  else {
    if (0 === this.transports.length) {
      var t2 = this;
      return void setTimeout(function() {
        t2.emit("error", "No transports available");
      }, 0);
    }
    e3 = this.transports[0];
  }
  this.readyState = "opening";
  try {
    e3 = this.createTransport(e3);
  } catch (e4) {
    return this.transports.shift(), void this.open();
  }
  e3.open(), this.setTransport(e3);
}, pt.prototype.setTransport = function(e3) {
  at("setting transport %s", e3.name);
  var t2 = this;
  this.transport && (at("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = e3, e3.on("drain", function() {
    t2.onDrain();
  }).on("packet", function(e4) {
    t2.onPacket(e4);
  }).on("error", function(e4) {
    t2.onError(e4);
  }).on("close", function() {
    t2.onClose("transport close");
  });
}, pt.prototype.probe = function(e3) {
  at('probing transport "%s"', e3);
  var t2 = this.createTransport(e3, { probe: 1 }), s2 = false, i2 = this;
  function n2() {
    if (i2.onlyBinaryUpgrades) {
      var n3 = !this.supportsBinary && i2.transport.supportsBinary;
      s2 = s2 || n3;
    }
    s2 || (at('probe transport "%s" opened', e3), t2.send([{ type: "ping", data: "probe" }]), t2.once("packet", function(n4) {
      if (!s2)
        if ("pong" === n4.type && "probe" === n4.data) {
          if (at('probe transport "%s" pong', e3), i2.upgrading = true, i2.emit("upgrading", t2), !t2)
            return;
          pt.priorWebsocketSuccess = "websocket" === t2.name, at('pausing current transport "%s"', i2.transport.name), i2.transport.pause(function() {
            s2 || "closed" !== i2.readyState && (at("changing transport and sending upgrade packet"), l2(), i2.setTransport(t2), t2.send([{ type: "upgrade" }]), i2.emit("upgrade", t2), t2 = null, i2.upgrading = false, i2.flush());
          });
        } else {
          at('probe transport "%s" failed', e3);
          var o3 = new Error("probe error");
          o3.transport = t2.name, i2.emit("upgradeError", o3);
        }
    }));
  }
  function o2() {
    s2 || (s2 = true, l2(), t2.close(), t2 = null);
  }
  function r2(s3) {
    var n3 = new Error("probe error: " + s3);
    n3.transport = t2.name, o2(), at('probe transport "%s" failed because of error: %s', e3, s3), i2.emit("upgradeError", n3);
  }
  function a2() {
    r2("transport closed");
  }
  function c2() {
    r2("socket closed");
  }
  function u2(e4) {
    t2 && e4.name !== t2.name && (at('"%s" works - aborting "%s"', e4.name, t2.name), o2());
  }
  function l2() {
    t2.removeListener("open", n2), t2.removeListener("error", r2), t2.removeListener("close", a2), i2.removeListener("close", c2), i2.removeListener("upgrading", u2);
  }
  pt.priorWebsocketSuccess = false, t2.once("open", n2), t2.once("error", r2), t2.once("close", a2), this.once("close", c2), this.once("upgrading", u2), t2.open();
}, pt.prototype.onOpen = function() {
  if (at("socket open"), this.readyState = "open", pt.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) {
    at("starting upgrade probes");
    for (var e3 = 0, t2 = this.upgrades.length; e3 < t2; e3++)
      this.probe(this.upgrades[e3]);
  }
}, pt.prototype.onPacket = function(e3) {
  if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState)
    switch (at('socket receive: type "%s", data "%s"', e3.type, e3.data), this.emit("packet", e3), this.emit("heartbeat"), e3.type) {
      case "open":
        this.onHandshake(JSON.parse(e3.data));
        break;
      case "pong":
        this.setPing(), this.emit("pong");
        break;
      case "error":
        var t2 = new Error("server error");
        t2.code = e3.data, this.onError(t2);
        break;
      case "message":
        this.emit("data", e3.data), this.emit("message", e3.data);
    }
  else
    at('packet received with socket readyState "%s"', this.readyState);
}, pt.prototype.onHandshake = function(e3) {
  this.emit("handshake", e3), this.id = e3.sid, this.transport.query.sid = e3.sid, this.upgrades = this.filterUpgrades(e3.upgrades), this.pingInterval = e3.pingInterval, this.pingTimeout = e3.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat));
}, pt.prototype.onHeartbeat = function(e3) {
  clearTimeout(this.pingTimeoutTimer);
  var t2 = this;
  t2.pingTimeoutTimer = setTimeout(function() {
    "closed" !== t2.readyState && t2.onClose("ping timeout");
  }, e3 || t2.pingInterval + t2.pingTimeout);
}, pt.prototype.setPing = function() {
  var e3 = this;
  clearTimeout(e3.pingIntervalTimer), e3.pingIntervalTimer = setTimeout(function() {
    at("writing ping packet - expecting pong within %sms", e3.pingTimeout), e3.ping(), e3.onHeartbeat(e3.pingTimeout);
  }, e3.pingInterval);
}, pt.prototype.ping = function() {
  var e3 = this;
  this.sendPacket("ping", function() {
    e3.emit("ping");
  });
}, pt.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
}, pt.prototype.flush = function() {
  "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (at("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"));
}, pt.prototype.write = pt.prototype.send = function(e3, t2, s2) {
  return this.sendPacket("message", e3, t2, s2), this;
}, pt.prototype.sendPacket = function(e3, t2, s2, i2) {
  if ("function" == typeof t2 && (i2 = t2, t2 = void 0), "function" == typeof s2 && (i2 = s2, s2 = null), "closing" !== this.readyState && "closed" !== this.readyState) {
    (s2 = s2 || {}).compress = false !== s2.compress;
    var n2 = { type: e3, data: t2, options: s2 };
    this.emit("packetCreate", n2), this.writeBuffer.push(n2), i2 && this.once("flush", i2), this.flush();
  }
}, pt.prototype.close = function() {
  if ("opening" === this.readyState || "open" === this.readyState) {
    this.readyState = "closing";
    var e3 = this;
    this.writeBuffer.length ? this.once("drain", function() {
      this.upgrading ? i2() : t2();
    }) : this.upgrading ? i2() : t2();
  }
  function t2() {
    e3.onClose("forced close"), at("socket closing - telling transport to close"), e3.transport.close();
  }
  function s2() {
    e3.removeListener("upgrade", s2), e3.removeListener("upgradeError", s2), t2();
  }
  function i2() {
    e3.once("upgrade", s2), e3.once("upgradeError", s2);
  }
  return this;
}, pt.prototype.onError = function(e3) {
  at("socket error %j", e3), pt.priorWebsocketSuccess = false, this.emit("error", e3), this.onClose("transport error", e3);
}, pt.prototype.onClose = function(e3, t2) {
  if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
    at('socket close with reason: "%s"', e3);
    clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", e3, t2), this.writeBuffer = [], this.prevBufferLen = 0;
  }
}, pt.prototype.filterUpgrades = function(e3) {
  for (var t2 = [], s2 = 0, i2 = e3.length; s2 < i2; s2++)
    ~ct(this.transports, e3[s2]) && t2.push(e3[s2]);
  return t2;
}, I.exports = ht, I.exports.parser = A;
var mt = { exports: {} };
var ft = function(e3, t2) {
  for (var s2 = [], i2 = (t2 = t2 || 0) || 0; i2 < e3.length; i2++)
    s2[i2 - t2] = e3[i2];
  return s2;
};
var gt = function(e3, t2, s2) {
  return e3.on(t2, s2), { destroy: function() {
    e3.removeListener(t2, s2);
  } };
};
var yt = [].slice;
var Et = function(e3, t2) {
  if ("string" == typeof t2 && (t2 = e3[t2]), "function" != typeof t2)
    throw new Error("bind() requires a function");
  var s2 = yt.call(arguments, 2);
  return function() {
    return t2.apply(e3, s2.concat(yt.call(arguments)));
  };
};
!function(e3, t2) {
  var s2 = C, i2 = S.exports, n2 = ft, o2 = gt, r2 = Et, a2 = (c.exports("socket.io-client:socket"), ne), u2 = P;
  e3.exports = h2;
  var l2 = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 }, d2 = i2.prototype.emit;
  function h2(e4, t3, s3) {
    this.io = e4, this.nsp = t3, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = false, this.disconnected = true, this.flags = {}, s3 && s3.query && (this.query = s3.query), this.io.autoConnect && this.open();
  }
  i2(h2.prototype), h2.prototype.subEvents = function() {
    if (!this.subs) {
      var e4 = this.io;
      this.subs = [o2(e4, "open", r2(this, "onopen")), o2(e4, "packet", r2(this, "onpacket")), o2(e4, "close", r2(this, "onclose"))];
    }
  }, h2.prototype.open = h2.prototype.connect = function() {
    return this.connected || (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting")), this;
  }, h2.prototype.send = function() {
    var e4 = n2(arguments);
    return e4.unshift("message"), this.emit.apply(this, e4), this;
  }, h2.prototype.emit = function(e4) {
    if (l2.hasOwnProperty(e4))
      return d2.apply(this, arguments), this;
    var t3 = n2(arguments), i3 = { type: (void 0 !== this.flags.binary ? this.flags.binary : u2(t3)) ? s2.BINARY_EVENT : s2.EVENT, data: t3, options: {} };
    return i3.options.compress = !this.flags || false !== this.flags.compress, "function" == typeof t3[t3.length - 1] && (this.ids, this.acks[this.ids] = t3.pop(), i3.id = this.ids++), this.connected ? this.packet(i3) : this.sendBuffer.push(i3), this.flags = {}, this;
  }, h2.prototype.packet = function(e4) {
    e4.nsp = this.nsp, this.io.packet(e4);
  }, h2.prototype.onopen = function() {
    if ("/" !== this.nsp)
      if (this.query) {
        var e4 = "object" == typeof this.query ? a2.encode(this.query) : this.query;
        this.packet({ type: s2.CONNECT, query: e4 });
      } else
        this.packet({ type: s2.CONNECT });
  }, h2.prototype.onclose = function(e4) {
    this.connected = false, this.disconnected = true, delete this.id, this.emit("disconnect", e4);
  }, h2.prototype.onpacket = function(e4) {
    var t3 = e4.nsp === this.nsp, i3 = e4.type === s2.ERROR && "/" === e4.nsp;
    if (t3 || i3)
      switch (e4.type) {
        case s2.CONNECT:
          this.onconnect();
          break;
        case s2.EVENT:
        case s2.BINARY_EVENT:
          this.onevent(e4);
          break;
        case s2.ACK:
        case s2.BINARY_ACK:
          this.onack(e4);
          break;
        case s2.DISCONNECT:
          this.ondisconnect();
          break;
        case s2.ERROR:
          this.emit("error", e4.data);
      }
  }, h2.prototype.onevent = function(e4) {
    var t3 = e4.data || [];
    null != e4.id && t3.push(this.ack(e4.id)), this.connected ? d2.apply(this, t3) : this.receiveBuffer.push(t3);
  }, h2.prototype.ack = function(e4) {
    var t3 = this, i3 = false;
    return function() {
      if (!i3) {
        i3 = true;
        var o3 = n2(arguments);
        t3.packet({ type: u2(o3) ? s2.BINARY_ACK : s2.ACK, id: e4, data: o3 });
      }
    };
  }, h2.prototype.onack = function(e4) {
    var t3 = this.acks[e4.id];
    "function" == typeof t3 ? (e4.id, e4.data, t3.apply(this, e4.data), delete this.acks[e4.id]) : e4.id;
  }, h2.prototype.onconnect = function() {
    this.connected = true, this.disconnected = false, this.emit("connect"), this.emitBuffered();
  }, h2.prototype.emitBuffered = function() {
    var e4;
    for (e4 = 0; e4 < this.receiveBuffer.length; e4++)
      d2.apply(this, this.receiveBuffer[e4]);
    for (this.receiveBuffer = [], e4 = 0; e4 < this.sendBuffer.length; e4++)
      this.packet(this.sendBuffer[e4]);
    this.sendBuffer = [];
  }, h2.prototype.ondisconnect = function() {
    this.nsp, this.destroy(), this.onclose("io server disconnect");
  }, h2.prototype.destroy = function() {
    if (this.subs) {
      for (var e4 = 0; e4 < this.subs.length; e4++)
        this.subs[e4].destroy();
      this.subs = null;
    }
    this.io.destroy(this);
  }, h2.prototype.close = h2.prototype.disconnect = function() {
    return this.connected && (this.nsp, this.packet({ type: s2.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }, h2.prototype.compress = function(e4) {
    return this.flags.compress = e4, this;
  }, h2.prototype.binary = function(e4) {
    return this.flags.binary = e4, this;
  };
}(mt);
var vt;
var Ct;
var St = bt;
function bt(e3) {
  e3 = e3 || {}, this.ms = e3.min || 100, this.max = e3.max || 1e4, this.factor = e3.factor || 2, this.jitter = e3.jitter > 0 && e3.jitter <= 1 ? e3.jitter : 0, this.attempts = 0;
}
bt.prototype.duration = function() {
  var e3 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t2 = Math.random(), s2 = Math.floor(t2 * this.jitter * e3);
    e3 = 0 == (1 & Math.floor(10 * t2)) ? e3 - s2 : e3 + s2;
  }
  return 0 | Math.min(e3, this.max);
}, bt.prototype.reset = function() {
  this.attempts = 0;
}, bt.prototype.setMin = function(e3) {
  this.ms = e3;
}, bt.prototype.setMax = function(e3) {
  this.max = e3;
}, bt.prototype.setJitter = function(e3) {
  this.jitter = e3;
};
var wt = class _wt {
  static get(e3) {
    const t2 = encodeURIComponent(e3) + "=", s2 = document.cookie.split("; ");
    for (const e4 of s2)
      if (e4.startsWith(t2))
        return decodeURIComponent(e4.substring(t2.length));
    return null;
  }
  static set(e3, t2, s2, i2, n2 = "/", o2 = false) {
    let r2 = encodeURIComponent(e3) + "=" + encodeURIComponent(t2);
    s2 instanceof Date && (r2 += "; expires=" + s2.toGMTString()), n2 && (r2 += "; path=" + n2), i2 && (r2 += "; domain=" + i2), o2 && (r2 += "; secure"), document.cookie = r2;
  }
  static remove(e3, t2, s2 = "/", i2 = false) {
    _wt.set(e3, "", /* @__PURE__ */ new Date(0), t2, s2, i2);
  }
};
!function(e3) {
  e3.BROWSER = "BROWSER", e3.UNKNOWN = "UNKNOWN", e3.APP_IOS = "APP_IOS", e3.APP_ANDROID = "APP_ANDROID", e3.APPLET_WX = "APPLET_WX", e3.APPLET_WX_GAME = "APPLET_WX_GAME", e3.APPLET_ALIPAY = "APPLET_ALIPAY", e3.APPLET_BYTEDANCE = "APPLET_BYTEDANCE";
}(vt || (vt = {}));
var It = class _It {
  constructor() {
    this.platform = null, this.methods = { [vt.BROWSER]: this.isBrowser, [vt.APP_IOS]: this.isAppiOS, [vt.APP_ANDROID]: this.isAppAndroid, [vt.APPLET_WX]: this.isWXApplet, [vt.APPLET_WX_GAME]: this.isWXGameApplet };
    const e3 = this.methods, t2 = Object.keys(e3);
    for (const s2 of t2) {
      if ((0, e3[s2])()) {
        this.platform = s2;
        break;
      }
    }
    this.platform = this.platform || vt.UNKNOWN, this.platform;
  }
  static currentPlatform() {
    return _It.instance.platform;
  }
  isBrowser() {
    return "undefined" != typeof navigator && "Taro" !== navigator.product && "ReactNative" !== navigator.product && "undefined" == typeof GameGlobal && ("undefined" == typeof cc || null !== cc.sys.browserType);
  }
  isAppiOS() {
    return "undefined" != typeof cc && cc.sys.isNative && cc.sys.isMobile && "iOS" === cc.sys.os || "object" == typeof uni && !!uni.getSystemInfoSync && "ios" === uni.getSystemInfoSync().platform && "object" == typeof plus;
  }
  isAppAndroid() {
    return "undefined" != typeof cc && cc.sys.isNative && cc.sys.isMobile && "Android" === cc.sys.os || "object" == typeof uni && !!uni.getSystemInfoSync && "android" === uni.getSystemInfoSync().platform && "object" == typeof plus;
  }
  isWXApplet() {
    return "object" == typeof wx && !!wx.getSystemInfoSync && "undefined" == typeof WebSocket && "undefined" == typeof XMLHttpRequest && "undefined" == typeof plus;
  }
  isWXGameApplet() {
    return "object" == typeof GameGlobal;
  }
  isAlipayApplet() {
    return false;
  }
  isBytedanceApplet() {
    return false;
  }
  isQQApplet() {
    return false;
  }
  isBaiduApplet() {
    return false;
  }
};
It.instance = new It(), function(e3) {
  e3.UNIAPP = "UNIAPP", e3.REACT_NATIVE = "REACT_NATIVE", e3.COCOS = "COCOS", e3.TARO = "TARO", e3.IONIC = "IONIC", e3.NATIVE_APPLET_WX = "NATIVE_APPLET_WX", e3.NATIVE_APPLET_ALIPAY = "NATIVE_APPLET_ALIPAY", e3.UNKNOWN = "UNKNOWN";
}(Ct || (Ct = {}));
var Mt = class {
  constructor() {
    this.framework = null, this.methods = { [Ct.UNIAPP]: this.isUniApp, [Ct.REACT_NATIVE]: this.isReactNative, [Ct.TARO]: this.isTaro, [Ct.NATIVE_APPLET_WX]: this.isWXApplet, [Ct.COCOS]: this.isCocos };
    const e3 = this.methods, t2 = Object.keys(e3);
    for (const s2 of t2) {
      if ((0, e3[s2])()) {
        this.framework = s2;
        break;
      }
    }
    this.framework = this.framework || Ct.UNKNOWN, this.framework;
  }
  static currentFramework() {
    return this.instance.framework;
  }
  isUniApp() {
    return "object" == typeof uni && !!uni.getSystemInfoSync;
  }
  isReactNative() {
    return "undefined" != typeof global && global.__fbGenNativeModule;
  }
  isTaro() {
    return "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.TARO_ENV;
  }
  isWXApplet() {
    return It.currentPlatform() === vt.APPLET_WX && "undefined" == typeof uni;
  }
  isCocos() {
    try {
      return void 0 !== cc.sys.localStorage;
    } catch (e3) {
      return false;
    }
  }
};
Mt.instance = new Mt();
var At = class {
  static init(e3) {
    Mt.currentFramework() === Ct.REACT_NATIVE && (this.validate(e3), this.platform = e3.platform, this.asyncStorage = e3.asyncStorage);
  }
  static validate(e3) {
    if (!e3)
      throw new Error("'reactNativeOptions' is missing when calling GoEasy.getInstance()");
    if (!e3.platform)
      throw new Error("'platform' is missing in GoEasy 'reactNativeOptions'");
    if (!e3.asyncStorage)
      throw new Error("'asyncStorage' is missing in GoEasy 'reactNativeOptions'");
  }
};
var Tt = class {
  asyncGet(e3) {
    let t2 = this.get(e3);
    return Promise.resolve(t2);
  }
  asyncPut(e3, t2) {
    return this.put(e3, t2), Promise.resolve();
  }
  get(e3) {
    let t2 = this.doGet(e3);
    return t2 = JSON.parse(t2), t2;
  }
  put(e3, t2) {
    this.doPut(e3, JSON.stringify(t2));
  }
};
var Nt = class extends Tt {
  constructor() {
    super(), this.domain = null;
    this.domain = "undefined" != typeof location && /^(?:[A-za-z0-9-]+\.)+[A-za-z]{2,4}(?:[\/\?#][\/=\?%\-&~`@[\]\':+!\.#\w]*)?$/.test(location.host) ? location.host.split(".").slice(-2).join(".") : null;
  }
  doGet(e3) {
    return wt.get(e3) || null;
  }
  doPut(e3, t2) {
    const s2 = new Date(2030, 12, 31, 0, 0, 0, 0), i2 = this.domain;
    wt.set(e3, t2, s2, i2);
  }
  remove(e3) {
    const t2 = this.domain;
    wt.remove(e3, t2);
  }
  support() {
    return "undefined" != typeof navigator && true === navigator.cookieEnabled;
  }
};
var Rt = class extends Tt {
  doGet(e3) {
    return localStorage.getItem(e3) || null;
  }
  doPut(e3, t2) {
    localStorage.setItem(e3, t2);
  }
  remove(e3) {
    localStorage.removeItem(e3);
  }
  support() {
    return !("undefined" != typeof GameGlobal || "undefined" == typeof localStorage || !localStorage.setItem);
  }
};
var Ot = class extends Tt {
  doGet(e3) {
    return uni.getStorageSync(e3) || null;
  }
  doPut(e3, t2) {
    uni.setStorageSync(e3, t2);
  }
  remove(e3) {
    uni.removeStorageSync(e3);
  }
  support() {
    return !("object" != typeof uni || !uni.getStorageSync);
  }
};
var _t = class extends Tt {
  doGet(e3) {
    return cc.sys.localStorage.getItem(e3) || null;
  }
  doPut(e3, t2) {
    cc.sys.localStorage.setItem(e3, t2);
  }
  remove(e3) {
    cc.sys.localStorage.removeItem(e3);
  }
  support() {
    return "undefined" != typeof cc && void 0 !== cc.sys.localStorage;
  }
};
var Pt = class extends Tt {
  doGet(e3) {
    return wx.getStorageSync(e3) || null;
  }
  doPut(e3, t2) {
    wx.setStorageSync(e3, t2);
  }
  remove(e3) {
    wx.removeStorageSync(e3);
  }
  support() {
    return !("object" != typeof wx || !wx.getStorageSync);
  }
};
var kt = class extends Tt {
  asyncGet(e3) {
    return t(this, void 0, void 0, function* () {
      const t2 = yield At.asyncStorage.getItem(e3);
      return JSON.parse(t2);
    });
  }
  asyncPut(e3, t2) {
    return At.asyncStorage.setItem(e3, JSON.stringify(t2));
  }
  doPut(e3, t2) {
    throw new Error("Method not implemented.");
  }
  remove(e3) {
    At.asyncStorage.removeItem(e3);
  }
  support() {
    return Mt.currentFramework() === Ct.REACT_NATIVE;
  }
  doGet(e3) {
    throw new Error("Method not implemented.");
  }
};
var Dt = class _Dt {
  constructor() {
    this.supportedStorage = null;
    const e3 = _Dt.storages;
    e3.push(new Ot()), e3.push(new _t()), e3.push(new Rt()), e3.push(new Pt()), e3.push(new kt()), e3.push(new Nt()), this.dispatch(), this.supportedStorage;
  }
  static localStorage() {
    return this.instance.supportedStorage;
  }
  dispatch() {
    for (let e3 of _Dt.storages)
      if (e3.support()) {
        this.supportedStorage = e3;
        break;
      }
  }
};
Dt.storages = new Array(), Dt.instance = new Dt();
var xt = new class {
  init() {
    return t(this, void 0, void 0, function* () {
      this.support() && (this.index = Math.floor(Math.random() * (this.MAX - 1) + 1), null !== this.storage && (this.index = parseInt(yield this.storage.asyncGet(this.INDEX_KEY)) || this.index));
    });
  }
  constructor() {
    this.INDEX_KEY = "DOMAIN_INDEX", this.MAX = 5, this.storage = Dt.localStorage(), this.init();
  }
  refresh() {
    return t(this, void 0, void 0, function* () {
      let e3 = this.index;
      e3 > 0 && e3 < this.MAX ? e3 += 1 : e3 === this.MAX && (e3 = 1), null !== this.storage && (this.index = e3, yield this.storage.asyncPut(this.INDEX_KEY, e3));
    });
  }
  i() {
    let e3 = this.index;
    return this.refresh(), e3;
  }
  support() {
    return [vt.BROWSER].includes(It.currentPlatform());
  }
}();
var Ft = i(Object.freeze({ __proto__: null, domainIndex: xt }));
var Ut = new class {
  constructor() {
    this.uniAppRunningBackend = false, this.listenAppRunning();
  }
  listenAppRunning() {
    Mt.currentFramework() === Ct.UNIAPP && "object" == typeof plus && (plus.globalEvent.addEventListener("resume", () => {
      this.uniAppRunningBackend = false, this.uniAppRunningBackend;
    }, false), plus.globalEvent.addEventListener("pause", () => {
      this.uniAppRunningBackend = true, this.uniAppRunningBackend;
    }, false));
  }
  runningBackend() {
    return this.uniAppRunningBackend;
  }
}();
var Lt = i(Object.freeze({ __proto__: null, uniApp: Ut }));
var Gt = I.exports;
var Bt = mt.exports;
var qt = S.exports;
var jt = C;
var Vt = gt;
var Ht = Et;
var Wt = (c.exports("socket.io-client:manager"), nt);
var zt = St;
var { domainIndex: Xt } = Ft;
var Jt;
var Yt = Lt.uniApp;
var Qt = Object.prototype.hasOwnProperty;
var $t = Kt;
function Kt(e3, t2) {
  if (!(this instanceof Kt))
    return new Kt(e3, t2);
  e3 && "object" == typeof e3 && (t2 = e3, e3 = void 0), (t2 = t2 || {}).path = t2.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = t2, this.reconnection(false !== t2.reconnection), this.reconnectionAttempts(t2.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t2.reconnectionDelay || 1e3), this.reconnectionDelayMax(t2.reconnectionDelayMax || 5e3), this.randomizationFactor(t2.randomizationFactor || 0.5), this.backoff = new zt({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(null == t2.timeout ? 2e4 : t2.timeout), this.readyState = "closed", this.uri = e3, this.connecting = [], this.lastPing = null, this.encoding = false, this.packetBuffer = [];
  var s2 = t2.parser || jt;
  this.encoder = new s2.Encoder(), this.decoder = new s2.Decoder(), this.autoConnect = false !== t2.autoConnect, this.autoConnect && this.open();
}
function Zt() {
  var e3 = false;
  return "object" == typeof uni && uni.getSystemInfo && (e3 = true), e3 && Yt.runningBackend();
}
Kt.prototype.emitAll = function() {
  for (var e3 in this.emit.apply(this, arguments), this.nsps)
    Qt.call(this.nsps, e3) && this.nsps[e3].emit.apply(this.nsps[e3], arguments);
}, Kt.prototype.updateSocketIds = function() {
  for (var e3 in this.nsps)
    Qt.call(this.nsps, e3) && (this.nsps[e3].id = this.generateId(e3));
}, Kt.prototype.generateId = function(e3) {
  return ("/" === e3 ? "" : e3 + "#") + this.engine.id;
}, qt(Kt.prototype), Kt.prototype.reconnection = function(e3) {
  return arguments.length ? (this._reconnection = !!e3, this) : this._reconnection;
}, Kt.prototype.reconnectionAttempts = function(e3) {
  return arguments.length ? (this._reconnectionAttempts = e3, this) : this._reconnectionAttempts;
}, Kt.prototype.reconnectionDelay = function(e3) {
  return arguments.length ? (this._reconnectionDelay = e3, this.backoff && this.backoff.setMin(e3), this) : this._reconnectionDelay;
}, Kt.prototype.randomizationFactor = function(e3) {
  return arguments.length ? (this._randomizationFactor = e3, this.backoff && this.backoff.setJitter(e3), this) : this._randomizationFactor;
}, Kt.prototype.reconnectionDelayMax = function(e3) {
  return arguments.length ? (this._reconnectionDelayMax = e3, this.backoff && this.backoff.setMax(e3), this) : this._reconnectionDelayMax;
}, Kt.prototype.timeout = function(e3) {
  return arguments.length ? (this._timeout = e3, this) : this._timeout;
}, Kt.prototype.maybeReconnectOnOpen = function() {
  !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
}, Kt.prototype.open = Kt.prototype.connect = function(e3, t2) {
  if (this.readyState, ~this.readyState.indexOf("open"))
    return this;
  this.uri, this.engine = Gt(this.uri, this.opts);
  var s2 = this.engine, i2 = this;
  this.readyState = "opening", this.skipReconnect = false;
  var n2 = Vt(s2, "open", function() {
    i2.onopen(), e3 && e3();
  }), o2 = Vt(s2, "error", async function(t3) {
    if (Xt.support()) {
      var s3 = parseInt(i2.uri.match(/[1-9][0-9]*/g)[0]), n3 = await Xt.i();
      i2.uri = i2.uri.replace(s3, n3);
    }
    if (i2.cleanup(), i2.readyState = "closed", i2.emitAll("connect_error", t3), e3) {
      var o3 = new Error("Connection error");
      o3.data = t3, e3(o3);
    } else
      i2.maybeReconnectOnOpen();
  });
  if (false !== this._timeout) {
    var r2 = this._timeout, a2 = setTimeout(function() {
      n2.destroy(), s2.close(), s2.emit("error", "timeout"), i2.emitAll("connect_timeout", r2);
    }, r2);
    this.subs.push({ destroy: function() {
      clearTimeout(a2);
    } });
  }
  return this.subs.push(n2), this.subs.push(o2), this;
}, Kt.prototype.onopen = function() {
  this.cleanup(), this.readyState = "open", this.emit("open");
  var e3 = this.engine;
  this.subs.push(Vt(e3, "data", Ht(this, "ondata"))), this.subs.push(Vt(e3, "ping", Ht(this, "onping"))), this.subs.push(Vt(e3, "pong", Ht(this, "onpong"))), this.subs.push(Vt(e3, "error", Ht(this, "onerror"))), this.subs.push(Vt(e3, "close", Ht(this, "onclose"))), this.subs.push(Vt(this.decoder, "decoded", Ht(this, "ondecoded")));
}, Kt.prototype.onping = function() {
  this.lastPing = /* @__PURE__ */ new Date(), this.emitAll("ping");
}, Kt.prototype.onpong = function() {
  this.emitAll("pong", /* @__PURE__ */ new Date() - this.lastPing);
}, Kt.prototype.ondata = function(e3) {
  this.decoder.add(e3);
}, Kt.prototype.ondecoded = function(e3) {
  this.emit("packet", e3);
}, Kt.prototype.onerror = function(e3) {
  this.emitAll("error", e3);
}, Kt.prototype.socket = function(e3, t2) {
  var s2 = this.nsps[e3];
  if (!s2) {
    s2 = new Bt(this, e3, t2), this.nsps[e3] = s2;
    var i2 = this;
    s2.on("connecting", n2), s2.on("connect", function() {
      s2.id = i2.generateId(e3);
    }), this.autoConnect && n2();
  }
  function n2() {
    ~Wt(i2.connecting, s2) || i2.connecting.push(s2);
  }
  return s2;
}, Kt.prototype.destroy = function(e3) {
  var t2 = Wt(this.connecting, e3);
  ~t2 && this.connecting.splice(t2, 1), this.connecting.length || this.close();
}, Kt.prototype.packet = function(e3) {
  var t2 = this;
  e3.query && 0 === e3.type && (e3.nsp += "?" + e3.query), t2.encoding ? t2.packetBuffer.push(e3) : (t2.encoding = true, this.encoder.encode(e3, function(s2) {
    for (var i2 = 0; i2 < s2.length; i2++)
      t2.engine.write(s2[i2], e3.options);
    t2.encoding = false, t2.processPacketQueue();
  }));
}, Kt.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var e3 = this.packetBuffer.shift();
    this.packet(e3);
  }
}, Kt.prototype.cleanup = function() {
  for (var e3 = this.subs.length, t2 = 0; t2 < e3; t2++) {
    this.subs.shift().destroy();
  }
  this.packetBuffer = [], this.encoding = false, this.lastPing = null, this.decoder.destroy();
}, Kt.prototype.close = Kt.prototype.disconnect = function() {
  this.skipReconnect = true, this.reconnecting = false, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close();
}, Kt.prototype.onclose = function(e3) {
  this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", e3), this._reconnection && !this.skipReconnect && this.reconnect();
}, Kt.prototype.reconnect = function() {
  if (Zt(), this.reconnecting || this.skipReconnect)
    return this;
  var e3 = this;
  if (this.backoff.attempts >= this._reconnectionAttempts)
    this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = false;
  else {
    var t2 = this.backoff.duration();
    this.reconnecting = true;
    var s2 = setTimeout(function() {
      e3.skipReconnect || (e3.emitAll("reconnect_attempt", e3.backoff.attempts), e3.emitAll("reconnecting", e3.backoff.attempts), e3.skipReconnect || (Zt() ? (e3.reconnecting = false, e3.reconnect(), e3.emitAll("reconnect_error", "Uniapp running backend, skipped reconnect...")) : e3.open(function(t3) {
        t3 ? (e3.reconnecting = false, e3.reconnect(), e3.emitAll("reconnect_error", t3.data)) : e3.onreconnect();
      })));
    }, t2);
    this.subs.push({ destroy: function() {
      clearTimeout(s2);
    } });
  }
}, Kt.prototype.onreconnect = function() {
  var e3 = this.backoff.attempts;
  this.reconnecting = false, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", e3);
}, function(e3, t2) {
  var s2 = v, i2 = C, n2 = $t;
  c.exports("socket.io-client");
  e3.exports = t2 = r2;
  var o2 = t2.managers = {};
  function r2(e4, t3) {
    "object" == typeof e4 && (t3 = e4, e4 = void 0), t3 = t3 || {};
    var i3, r3 = s2(e4), a2 = r3.source, c2 = r3.id, u2 = r3.path, l2 = o2[c2] && u2 in o2[c2].nsps;
    return t3.forceNew || t3["force new connection"] || false === t3.multiplex || l2 ? i3 = n2(a2, t3) : (o2[c2] || (o2[c2] = n2(a2, t3)), i3 = o2[c2]), r3.query && !t3.query && (t3.query = r3.query), i3.socket(r3.path, t3);
  }
  t2.protocol = i2.protocol, t2.connect = r2, t2.Manager = $t, t2.Socket = mt.exports;
}(n, n.exports), function(e3) {
  e3.WRITE = "WRITE", e3.READ = "READ", e3.NONE = "NONE";
}(Jt || (Jt = {}));
var es = new class {
  isDef(e3) {
    return !this.isUndef(e3);
  }
  isUndef(e3) {
    return null == e3;
  }
  isPrimitive(e3) {
    return "string" == typeof e3 || "number" == typeof e3 || "symbol" == typeof e3 || "boolean" == typeof e3;
  }
  isObject(e3) {
    return null !== e3 && "object" == typeof e3;
  }
  isPlainObject(e3) {
    return "[object Object]" === Object.prototype.toString.call(e3);
  }
  isRegExp(e3) {
    return "[object RegExp]" === Object.prototype.toString.call(e3);
  }
  isValidArrayIndex(e3) {
    let t2 = parseFloat(String(e3));
    return t2 >= 0 && Math.floor(t2) === t2 && isFinite(e3);
  }
  isString(e3) {
    return "string" == typeof e3;
  }
  isNumber(e3) {
    return "number" == typeof e3;
  }
  isStringOrNumber(e3) {
    return this.isString(e3) || this.isNumber(e3);
  }
  isArray(e3) {
    return "[object Array]" === Object.prototype.toString.call(e3);
  }
  isEmpty(e3) {
    return this.isArray(e3) ? 0 === e3.length : this.isObject(e3) ? !this.isDef(e3) : !this.isNumber(e3) && (this.isString(e3) ? "" === e3.trim() : !this.isDef(e3));
  }
  isNative(e3) {
    return "function" == typeof e3 && /native code/.test(e3.toString());
  }
  isFunction(e3) {
    return "function" == typeof e3;
  }
  isBoolean(e3) {
    return "boolean" == typeof e3;
  }
  isTrue(e3) {
    return true === e3;
  }
  isFalse(e3) {
    return false === e3;
  }
  isNull(e3) {
    return null === e3;
  }
}();
var ts = n.exports;
var ss = class {
  constructor() {
    this.io = ts, this.status = e.DISCONNECTED, this.permissions = [Jt.NONE], this.connectedObservers = [], this.disconnectedObservers = [];
  }
  connect() {
    this.status = e.CONNECTING;
  }
  socketio() {
    return this.io;
  }
  on(e3, t2) {
    this.io.on(e3, t2);
  }
  disconnect() {
    this.io.disconnect();
  }
  getStatus() {
    return this.status;
  }
  addConnectedObserver(e3) {
    es.isFunction(e3) && this.connectedObservers.push(e3);
  }
  addDisconnectedObserver(e3) {
    es.isFunction(e3) && this.disconnectedObservers.push(e3);
  }
  notify(e3, t2) {
    for (let s2 = 0; s2 < e3.length; s2++)
      e3[s2](t2);
  }
};
var is = class extends ss {
  constructor(e3) {
    super(), this.reconnectingObservers = [], this.addReconnectingObserver(e3.onReconnecting), this.addDisconnectedObserver(e3.onDisconnected);
  }
  connect(e3) {
    super.connect(), this.io = this.io.connect(e3.uri, e3.opts), this.initListener();
  }
  initListener() {
    this.io.on("connect", () => {
      this.status = e.CONNECTED, this.notify(this.connectedObservers);
    }), this.io.on("reconnecting", (t2) => {
      this.status = e.CONNECTING, this.notify(this.reconnectingObservers, t2);
    }), this.io.on("disconnect", () => {
      this.status = e.DISCONNECTED, this.notify(this.disconnectedObservers);
    }), this.io.on("connect_error", function(e3) {
    });
  }
  addReconnectingObserver(e3) {
    this.reconnectingObservers.push(e3);
  }
};
var ns = { exports: {} };
var os = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
if (os) {
  rs = new Uint8Array(16);
  ns.exports = function() {
    return os(rs), rs;
  };
} else {
  as = new Array(16);
  ns.exports = function() {
    for (var e3, t2 = 0; t2 < 16; t2++)
      0 == (3 & t2) && (e3 = 4294967296 * Math.random()), as[t2] = e3 >>> ((3 & t2) << 3) & 255;
    return as;
  };
}
var rs;
var as;
for (cs = [], us = 0; us < 256; ++us)
  cs[us] = (us + 256).toString(16).substr(1);
var cs;
var us;
var ls;
var ds;
var hs = function(e3, t2) {
  var s2 = t2 || 0, i2 = cs;
  return [i2[e3[s2++]], i2[e3[s2++]], i2[e3[s2++]], i2[e3[s2++]], "-", i2[e3[s2++]], i2[e3[s2++]], "-", i2[e3[s2++]], i2[e3[s2++]], "-", i2[e3[s2++]], i2[e3[s2++]], "-", i2[e3[s2++]], i2[e3[s2++]], i2[e3[s2++]], i2[e3[s2++]], i2[e3[s2++]], i2[e3[s2++]]].join("");
};
var ps = ns.exports;
var ms = hs;
var fs = 0;
var gs = 0;
var ys = function(e3, t2, s2) {
  var i2 = t2 && s2 || 0, n2 = t2 || [], o2 = (e3 = e3 || {}).node || ls, r2 = void 0 !== e3.clockseq ? e3.clockseq : ds;
  if (null == o2 || null == r2) {
    var a2 = ps();
    null == o2 && (o2 = ls = [1 | a2[0], a2[1], a2[2], a2[3], a2[4], a2[5]]), null == r2 && (r2 = ds = 16383 & (a2[6] << 8 | a2[7]));
  }
  var c2 = void 0 !== e3.msecs ? e3.msecs : (/* @__PURE__ */ new Date()).getTime(), u2 = void 0 !== e3.nsecs ? e3.nsecs : gs + 1, l2 = c2 - fs + (u2 - gs) / 1e4;
  if (l2 < 0 && void 0 === e3.clockseq && (r2 = r2 + 1 & 16383), (l2 < 0 || c2 > fs) && void 0 === e3.nsecs && (u2 = 0), u2 >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  fs = c2, gs = u2, ds = r2;
  var d2 = (1e4 * (268435455 & (c2 += 122192928e5)) + u2) % 4294967296;
  n2[i2++] = d2 >>> 24 & 255, n2[i2++] = d2 >>> 16 & 255, n2[i2++] = d2 >>> 8 & 255, n2[i2++] = 255 & d2;
  var h2 = c2 / 4294967296 * 1e4 & 268435455;
  n2[i2++] = h2 >>> 8 & 255, n2[i2++] = 255 & h2, n2[i2++] = h2 >>> 24 & 15 | 16, n2[i2++] = h2 >>> 16 & 255, n2[i2++] = r2 >>> 8 | 128, n2[i2++] = 255 & r2;
  for (var p2 = 0; p2 < 6; ++p2)
    n2[i2 + p2] = o2[p2];
  return t2 || ms(n2);
};
var Es = ns.exports;
var vs = hs;
var Cs = function(e3, t2, s2) {
  var i2 = t2 && s2 || 0;
  "string" == typeof e3 && (t2 = "binary" === e3 ? new Array(16) : null, e3 = null);
  var n2 = (e3 = e3 || {}).random || (e3.rng || Es)();
  if (n2[6] = 15 & n2[6] | 64, n2[8] = 63 & n2[8] | 128, t2)
    for (var o2 = 0; o2 < 16; ++o2)
      t2[i2 + o2] = n2[o2];
  return t2 || vs(n2);
};
var Ss = ys;
var bs = Cs;
var ws = bs;
ws.v1 = Ss, ws.v4 = bs;
var Is = ws;
var Ms = class {
  static get() {
    return Is.v1().replace(/-/g, "");
  }
};
var As = class {
  constructor(e3) {
    this.permission = Jt.NONE, this.singleTimeout = 0, this.totalTimeout = 0, this.startTime = 0, this.complete = false, this.retried = 0, this.unique = false, this.uuid = Ms.get(), this.name = e3.name, this.params = e3.params, this.permission = e3.permission, this.totalTimeout = e3.totalTimeout, this.singleTimeout = e3.singleTimeout, e3.unique && (this.unique = e3.unique), this.success = (t2) => {
      this.complete || (this.end(), e3.success(t2));
    }, this.fail = (t2) => {
      this.complete || (this.end(), e3.fail(t2));
    };
  }
  start() {
    this.startTime = Date.now(), this.initAutoTimeout();
  }
  end() {
    this.complete = true, clearTimeout(this.timeoutHandler);
  }
  initAutoTimeout() {
    this.timeoutHandler = setTimeout(() => {
      this.complete || this.fail({ resultCode: 408, content: "Host unreachable or timeout" });
    }, this.totalTimeout);
  }
};
function Ts(...e3) {
}
var Ns = class {
  constructor(e3) {
    this.callback = Ts, this.guidList = [], this.callback = e3;
  }
  onMessage(e3, t2) {
    if ("string" == typeof t2 && (t2 = JSON.parse(t2)), t2.i) {
      if (this.guidList.findIndex((e4) => e4 === t2.i) > -1)
        return;
      this.guidList.unshift(t2.i), this.guidList.length > 300 && this.guidList.pop();
    }
    this.callback(t2);
  }
};
var Rs;
var Os;
!function(e3) {
  e3[e3.connect = 3e3] = "connect", e3[e3.reconnectionDelayMax = 3e3] = "reconnectionDelayMax", e3[e3.commonQuerySingle = 2500] = "commonQuerySingle", e3[e3.commonQueryTotal = 12e3] = "commonQueryTotal", e3[e3.commonRequestSingle = 1700] = "commonRequestSingle", e3[e3.commonRequestTotal = 12e3] = "commonRequestTotal", e3[e3.commonInfiniteSingle = 1700] = "commonInfiniteSingle", e3[e3.commonInfiniteTotal = 864e5] = "commonInfiniteTotal";
}(Rs || (Rs = {})), function(e3) {
  e3.authorize = "authorize", e3.manualDisconnect = "manualDisconnect", e3.subscribe = "subscribe", e3.unsubscribe = "unsubscribe", e3.publish = "publish", e3.ack = "ack", e3.historyMessages = "historyMessages", e3.hereNow = "hereNow", e3.hereNowByUserIds = "hereNowByUserIds", e3.PUBSUB_PRESENCE_SUBSCRIBE = "PUBSUB_PRESENCE_SUBSCRIBE", e3.PUBSUB_PRESENCE_UNSUBSCRIBE = "PUBSUB_PRESENCE_UNSUBSCRIBE", e3.PUBSUB_PRESENCE_HERENOW = "PUBSUB_PRESENCE_HERENOW", e3.imLastConversations = "imLastConversations", e3.markPrivateMessageAsRead = "markPrivateMessageAsRead", e3.markGroupMessageAsRead = "markGroupMessageAsRead", e3.imGroupOnlineCount = "imGroupOnlineCount", e3.imHereNow = "imHereNow", e3.imGroupHereNow = "imGroupHereNow", e3.publishIM = "publishIM", e3.subscribeUserPresence = "subscribeUserPresence", e3.unsubscribeUserPresence = "unsubscribeUserPresence", e3.subscribeGroupPresence = "subscribeGroupPresence", e3.unsubscribeGroupPresence = "unsubscribeGroupPresence", e3.removeConversation = "removeConversation", e3.topConversation = "topConversation", e3.imData = "imData", e3.subscribeGroups = "subscribeGroups", e3.unsubscribeGroup = "unsubscribeGroup", e3.IM_DELETE_MESSAGE = "IM_DELETE_MESSAGE", e3.IM_HISTORY = "IM_HISTORY", e3.IM_HISTORY_CHANGE = "IM_HISTORY_CHANGE", e3.IM_RECALL_MESSAGE = "IM_RECALL_MESSAGE", e3.IM_MARK_AS_READ = "IM_MARK_AS_READ", e3.RTC_ASK_NEW_TOKEN = "RTC_ASK_NEW_TOKEN", e3.RTC_DIAL = "RTC_DIAL", e3.RTC_ACCEPT = "RTC_ACCEPT", e3.RTC_ACCEPT_FAILED = "RTC_ACCEPT_FAILED", e3.RTC_MANUAL_END = "RTC_MANUAL_END", e3.RTC_CLIENT_BUSY = "RTC_CLIENT_BUSY", e3.RTC_TIMEOUT = "RTC_TIMEOUT", e3.RTC_CALL_DATA = "RTC_CALL_DATA", e3.CS_PENDING_CONVERSATION = "CS_PENDING_CONVERSATION", e3.CS_ACCEPT = "CS_ACCEPT", e3.CS_END = "CS_END", e3.CS_TRANSFER = "CS_TRANSFER", e3.CS_AGENTS = "CS_AGENTS", e3.CS_CUSTOMER_STATUS = "CS_CUSTOMER_STATUS", e3.CS_MY_TEAMS = "CS_MY_TEAMS", e3.CS_ONLINE = "CS_ONLINE", e3.CS_OFFLINE = "CS_OFFLINE", e3.CS_LIVE_SESSION = "CS_LIVE_SESSION", e3.CS_QUIT_LIVE = "CS_QUIT_LIVE", e3.SET_IOS_BADGE = "SET_IOS_BADGE";
}(Os || (Os = {}));
var _s = "IM";
var Ps = "PUBSUB";
var ks = class {
  constructor(e3) {
    this.rocketsBuffer = /* @__PURE__ */ new Set(), this.socket = e3, this.socket.addConnectedObserver(this.onSocketConnected.bind(this));
  }
  emit(t2) {
    this.socket.status !== e.DISCONNECTED ? (t2.start(), this.doEmit(t2)) : t2.fail({ resultCode: "409", content: "Please connect first" });
  }
  doEmit(t2) {
    if (!t2.complete)
      if (this.socket.status !== e.CONNECT_FAILED)
        if (this.isConnected())
          if (this.hasPermission(t2)) {
            let e3 = setTimeout(() => {
              this.doEmit(t2);
            }, t2.singleTimeout);
            t2.unique && (t2.params.retried = t2.retried), this.socket.socketio().emit(t2.name, t2.params, (s2) => {
              clearTimeout(e3), 200 === s2.resultCode || 200 == s2.code ? t2.success(s2) : t2.fail(s2);
            }), t2.retried++;
          } else
            t2.fail({ resultCode: 401, content: "No permission" });
        else
          this.isConnecting() && this.rocketsBuffer.add(t2);
      else
        t2.fail({ resultCode: 408, content: "Failed to connect GoEasy." });
  }
  hasPermission(e3) {
    return !!this.socket.permissions.find((t2) => t2 === e3.permission);
  }
  isConnected() {
    return [e.CONNECTED, e.RECONNECTED, e.EXPIRED_RECONNECTED].includes(this.socket.status);
  }
  isConnecting() {
    return [e.CONNECTING, e.RECONNECTING].includes(this.socket.status);
  }
  onSocketConnected() {
    this.emitBuffer();
  }
  emitBuffer() {
    Array.from(this.rocketsBuffer).forEach((e3) => {
      this.rocketsBuffer.delete(e3), this.doEmit(e3);
    });
  }
};
var Ds = class {
  static i(e3) {
    this.socket = e3, this.emitter = new ks(e3);
  }
  static s() {
    if (this.socket)
      return this.socket;
    throw new Error("Please connect first.");
  }
  static e(e3) {
    this.emitter.emit(e3);
  }
  static u() {
    return this.s().userId;
  }
  static ud() {
    return this.s().connectOptions.data;
  }
  static supportIM() {
    return this.s().options.modules.includes(_s);
  }
};
var xs = class {
  static onSuccess(e3, t2) {
    es.isFunction(e3.onSuccess) && e3.onSuccess(t2);
  }
  static onFailed(e3, t2) {
    if (!es.isObject(e3) || !es.isFunction(e3.onFailed))
      throw t2;
    e3.onFailed(t2);
  }
};
var Fs = class _Fs {
  constructor(e3) {
    this.uniappPlugin = null, this.regIdPromise = null, this.onClickNotificationCallback = null, this.payloadAssemblers = new Array(), this.allowNotification = e3, this.supportNotification() && (this.uniappPlugin = uni.requireNativePlugin("GoEasy-Uniapp"), this.uniappPlugin ? this.regIdPromise = this.askRegId() : console.warn("No GoEasy-Uniapp Native Plugin."));
  }
  static init(e3) {
    this.instance = new _Fs(e3), this.instance.supportNotification() && this.instance.setClientBadge(0);
  }
  addAssembler(e3) {
    this.payloadAssemblers.push(e3);
  }
  assemblePayload(e3) {
    let t2 = this.payloadAssemblers.find((t3) => t3.support(e3));
    return t2 ? t2.assemble(e3) : e3;
  }
  createLocalNotification(e3, t2, s2, i2, n2) {
    Ut.runningBackend() && (s2.g = 1, "undefined" != typeof plus && (i2 ? (this.uniappPlugin.playSound(i2), plus.push.createMessage(t2, JSON.stringify(s2), { title: e3, sound: "none" })) : plus.push.createMessage(t2, JSON.stringify(s2), { title: e3 }), "+1" === n2 && this.setClientBadge(_Fs.instance.badge + 1)));
  }
  setBadge(e3) {
    if (!Number.isInteger(e3.badge) || e3.badge < 0)
      xs.onFailed(e3, "badge must be an integer greater than or equal to 0.");
    else if (this.supportNotification())
      if (It.currentPlatform() === vt.APP_IOS) {
        let t2 = new As({ name: Os.SET_IOS_BADGE, params: { badge: e3.badge }, unique: true, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, permission: Jt.WRITE, success: () => {
          xs.onSuccess(e3), this.setClientBadge(e3.badge);
        }, fail: (t3) => {
          xs.onFailed(e3, t3.content);
        } });
        Ds.e(t2);
      } else
        xs.onSuccess(e3), this.setClientBadge(e3.badge);
  }
  setClientBadge(e3) {
    "vivo" !== plus.device.vendor && (_Fs.instance.badge = e3, plus.runtime.setBadgeNumber(e3));
  }
  askRegId() {
    let e3 = null, t2 = 0;
    const s2 = () => new Promise((i2, n2) => {
      this.uniappPlugin.regId((e4) => {
        i2(e4);
      }, (i3) => {
        if (!(1e6 === i3.data.code && t2 <= 10))
          return clearTimeout(e3), n2(i3);
        e3 = setTimeout(() => {
          t2++, this.regIdPromise = s2();
        }, 3500);
      });
    });
    return s2();
  }
  getRegIdPromise() {
    return this.regIdPromise;
  }
  supportNotification() {
    const e3 = It.currentPlatform(), t2 = Mt.currentFramework();
    return this.allowNotification && t2 === Ct.UNIAPP && (e3 === vt.APP_ANDROID || e3 === vt.APP_IOS);
  }
  listenPlusClickNotification() {
    plus.push.addEventListener("click", (e3) => {
      try {
        if (e3) {
          const t2 = "string" == typeof e3.payload ? JSON.parse(e3.payload) : e3.payload;
          if (this.availableIntent(t2)) {
            let e4 = this.assemblePayload(t2);
            plus.push.clear(), this.onClickNotificationCallback(e4);
          }
        }
      } catch (e4) {
      }
    });
  }
  availableIntent(e3) {
    return e3 && Object.keys(e3).length && e3.g && 1 === parseInt(e3.g);
  }
  getIntentData() {
    this.uniappPlugin.getIntentData((e3) => {
      if (!this.availableIntent(e3))
        return;
      let t2 = this.assemblePayload(e3);
      const s2 = It.currentPlatform();
      plus.push.clear(), s2 === vt.APP_ANDROID && this.uniappPlugin.clearAll(), this.onClickNotificationCallback(t2);
    });
  }
  listenClick() {
    this.listenPlusClickNotification();
    const e3 = It.currentPlatform();
    this.uniappPlugin && e3 === vt.APP_ANDROID && this.getIntentData();
  }
  onClickNotification(e3) {
    if (this.supportNotification()) {
      if (!es.isFunction(e3))
        throw new Error("The arguments must be a function.");
      null === this.onClickNotificationCallback ? (this.onClickNotificationCallback = e3, this.listenClick()) : console.warn("The onClickNotification event has been listened on. Please do not listen to it more than once.");
    } else
      console.warn("The current environment doesn't support or allowNotification is false.");
  }
};
var Us = S.exports;
var Ls = class {
  constructor() {
    this.emitter = new Us();
  }
  on(e3, t2) {
    return this.emitter.on(e3, t2), this;
  }
  once(e3, t2) {
    return this.emitter.once(e3, t2), this;
  }
  off(e3, t2) {
    return this.emitter.off(e3, t2), this;
  }
  fire(e3, t2) {
    return this.emitter.emit(e3, t2), this;
  }
};
var Gs = class {
  static initial() {
    this.eventDriver = new Ls();
  }
  static on(e3, t2) {
    this.eventDriver.on(e3, t2);
  }
  static off(e3, t2) {
    this.eventDriver.off(e3, t2);
  }
  static once(e3, t2) {
    this.eventDriver.once(e3, t2);
  }
  static fire(e3, t2) {
    this.eventDriver.fire(e3, t2);
  }
};
var Bs;
!function(e3) {
  e3.MANUAL_DISCONNECTED = "MANUAL_DISCONNECTED";
}(Bs || (Bs = {}));
var qs = class _qs {
  static get() {
    return t(this, void 0, void 0, function* () {
      let e3, t2 = Dt.localStorage();
      return null !== t2 && (e3 = yield t2.asyncGet(_qs.SM_KEY)), e3;
    });
  }
  static put(e3) {
    return t(this, void 0, void 0, function* () {
      var t2 = Dt.localStorage();
      let s2 = e3.sm;
      null !== t2 && s2 && t2.asyncPut(_qs.SM_KEY, s2);
    });
  }
};
qs.SM_KEY = "GE-SM";
var js = class {
  static e(e3, t2) {
    function s2(e4) {
      return function(e5) {
        return e5 >= 32 && e5 <= 126;
      }(e4) ? String.fromCharCode(function(e5) {
        let s3 = e5 + t2;
        return s3 > 126 ? s3 - 126 + 32 : s3;
      }(e4)) : String.fromCharCode(e4);
    }
    let i2 = "";
    for (let t3 = 0; t3 < e3.length; t3++) {
      i2 += s2(e3.charCodeAt(t3));
    }
    return i2;
  }
};
var Vs = class {
  static initRNUniqueId() {
    if (Mt.currentFramework() === Ct.REACT_NATIVE) {
      let e3 = At.platform, t2 = e3.constants, s2 = { os: e3.OS };
      return "android" === s2.os ? s2.f = t2.Fingerprint : s2.v = e3.Version, JSON.stringify(s2);
    }
    return null;
  }
  static initPlusDeviceId() {
    return new Promise((e3, t2) => {
      "undefined" != typeof plus ? plus.device.getInfo({ success: (t3) => {
        e3(t3.uuid);
      }, fail: (e4) => {
        t2(e4);
      } }) : e3(null);
    });
  }
  static getVideoCard() {
    var e3;
    if (It.currentPlatform() === vt.BROWSER && "undefined" != typeof document) {
      const t2 = document.createElement("canvas"), s2 = null !== (e3 = t2.getContext("webgl")) && void 0 !== e3 ? e3 : t2.getContext("experimental-webgl");
      if (s2 && "getExtension" in s2) {
        let e4 = 0, t3 = 0;
        if (navigator.userAgent.indexOf("Firefox") > -1)
          t3 = s2.VENDOR, e4 = s2.RENDERER;
        else {
          let i3 = s2.getExtension("WEBGL_debug_renderer_info");
          if (!i3)
            return null;
          t3 = i3.UNMASKED_VENDOR_WEBGL, e4 = i3.UNMASKED_RENDERER_WEBGL;
        }
        const i2 = { vendor: (s2.getParameter(t3) || "").toString(), renderer: (s2.getParameter(e4) || "").toString() };
        return JSON.stringify(i2);
      }
    }
    return null;
  }
  static z() {
    return t(this, void 0, void 0, function* () {
      const e3 = { p: It.currentPlatform(), f: Mt.currentFramework(), pdi: yield this.initPlusDeviceId(), vc: this.getVideoCard(), rfp: this.initRNUniqueId() };
      return js.e(JSON.stringify(e3), 5);
    });
  }
};
var Hs = class extends ss {
  constructor(e3, t2) {
    super(), this.ioSocket = null, this.sid = null, this.anonymous = false, this.userId = null, this.artifactVersion = vo.version, this.uri = null, this.ioOpts = null, this.reconnectingTimes = 0, this.messageObservers = {}, this.connectFailedObservers = [], this.connectingObservers = [], this.expiredReconnectedObservers = [], this.options = e3, this.connectOptions = t2, this.ioSocket = new is({ onDisconnected: this.onIoDisconnected.bind(this), onReconnecting: this.onIoReconnecting.bind(this) }), this.ioSocketEmitter = new ks(this.ioSocket), this.ioSocket.addConnectedObserver(this.onIoReconnected.bind(this)), this.initUserId(), this.addConnectedObserver(t2.onSuccess), this.addConnectFailedObserver(t2.onFailed), this.addConnectingObserver(t2.onProgress);
  }
  initUserId() {
    let e3 = this.connectOptions.id;
    es.isEmpty(e3) ? this.anonymous = true : this.userId = e3.toString();
  }
  socketio() {
    return this.ioSocket.socketio();
  }
  extendOptions() {
    let e3 = this.connectOptions;
    if (es.isNull(e3.data) || es.isDef(e3.data) && !es.isObject(e3.data))
      throw { code: 400, content: "TypeError: data requires an object." };
    if ((es.isDef(e3.data) ? String(e3.data).length : 0) > 300 && es.isObject(e3) && es.isFunction(e3.onFailed))
      throw { code: 400, content: "user.data-length limit 300 byte." };
    if (es.isObject(e3.wxmpId)) {
      if (es.isEmpty(e3.wxmpId.appid))
        throw { code: 400, content: "wxmpId.appid is required." };
      if (es.isEmpty(e3.wxmpId.openid))
        throw { code: 400, content: "wxmpId.openid is required. requires string." };
    } else if (es.isPrimitive(e3.wxmpId))
      throw { code: 400, content: "TypeError: wxmpId requires an object." };
  }
  initUriAndOpts() {
    let e3 = this.options, t2 = true;
    if (xt.support()) {
      let s2, i2 = "://" + xt.i() + e3.host;
      true === e3.supportOldBrowser ? (s2 = ["polling", "websocket"], t2 = false) : s2 = ["websocket"], false !== e3.forceTLS && t2 ? this.uri = "https" + i2 + ":443" : this.uri = "http" + i2 + ":80", this.ioOpts = { transports: s2, timeout: Rs.connect };
    } else
      this.uri = "https://wx-" + e3.host + ":443", this.ioOpts = { transports: ["websocket"], reconnectionDelayMax: Rs.reconnectionDelayMax };
  }
  onIoReconnected() {
    this.status === e.RECONNECTING && this.authorize();
  }
  sendAck(e3, t2) {
    this.ioSocket.io.emit(e3, t2);
  }
  connect() {
    this.initUriAndOpts(), this.extendOptions(), super.connect(), this.onConnecting(), this.ioSocket.connect({ uri: this.uri, opts: this.ioOpts }), this.authorize();
  }
  disconnect() {
    return new Promise((t2, s2) => {
      let i2 = () => {
        this.status = e.DISCONNECTED, this.ioSocket.disconnect(), Gs.fire(Bs.MANUAL_DISCONNECTED), t2();
      };
      if (this.options.allowNotification) {
        let e3 = (e4) => {
          s2(e4);
        }, t3 = new As({ name: Os.manualDisconnect, params: {}, permission: Jt.READ, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: e3, success: i2 });
        Ds.e(t3);
      } else
        i2();
    });
  }
  initRegId() {
    return t(this, void 0, void 0, function* () {
      let e3 = Fs.instance;
      if (e3 && e3.supportNotification() && e3.getRegIdPromise())
        try {
          this.regId = yield e3.getRegIdPromise(), this.regId;
        } catch (e4) {
          console.warn("Failed to register the Manufacturers Push service:" + JSON.stringify(e4));
        }
    });
  }
  authorize() {
    return t(this, void 0, void 0, function* () {
      this.initRegId().then(() => t(this, void 0, void 0, function* () {
        let e3 = this.connectOptions, t2 = { appkey: this.options.appkey, userId: this.userId, userData: JSON.stringify(e3.data), otp: e3.otp, artifactVersion: this.artifactVersion, sid: this.sid, allowNT: this.options.allowNotification, regId: this.regId, wxmpId: e3.wxmpId, modules: this.options.modules, a: this.anonymous, z: yield Vs.z(), sm: yield qs.get() };
        JSON.stringify(t2);
        let s2 = new As({ name: Os.authorize, params: t2, permission: Jt.NONE, singleTimeout: Rs.commonInfiniteSingle, totalTimeout: Rs.commonInfiniteTotal, success: (e4) => {
          this.onAuthorizeSuccess(e4);
        }, fail: (e4) => {
          this.onAuthorizeFailed(e4);
        } });
        this.ioSocketEmitter.emit(s2);
      }));
    });
  }
  onConnecting() {
    this.notify(this.connectingObservers, this.reconnectingTimes);
  }
  onIoReconnecting() {
    this.reconnectingTimes++, this.status == e.CONNECTED || this.status == e.EXPIRED_RECONNECTED || this.status == e.RECONNECTING ? this.status = e.RECONNECTING : this.status = e.CONNECTING, this.onConnecting();
  }
  onIoDisconnected() {
    this.status == e.DISCONNECTING && (this.status = e.DISCONNECTED), this.notify(this.disconnectedObservers);
  }
  onAuthorizeSuccess(t2) {
    if (qs.put(t2), this.status === e.RECONNECTING) {
      this.sid !== t2.sid ? (this.status = e.EXPIRED_RECONNECTED, this.sid = t2.sid, this.notify(this.expiredReconnectedObservers)) : this.status = e.RECONNECTED;
    } else
      this.status = e.CONNECTED, this.sid = t2.sid;
    t2.enablePublish && (this.permissions.find((e3) => e3 == Jt.WRITE) || this.permissions.push(Jt.WRITE)), t2.enableSubscribe && (this.permissions.find((e3) => e3 == Jt.READ) || this.permissions.push(Jt.READ)), this.reconnectingTimes = 0, this.notify(this.connectedObservers);
  }
  onAuthorizeFailed(t2) {
    this.ioSocket.disconnect(), this.status = e.CONNECT_FAILED;
    let s2 = { code: t2.resultCode || 408, content: t2.content || "Host unreachable or timeout" };
    this.notify(this.connectFailedObservers, s2);
  }
  addConnectingObserver(e3) {
    es.isFunction(e3) && this.connectingObservers.push(e3);
  }
  addConnectFailedObserver(e3) {
    es.isFunction(e3) && this.connectFailedObservers.push(e3);
  }
  addExpiredReconnectedObserver(e3) {
    es.isFunction(e3) && this.expiredReconnectedObservers.push(e3);
  }
  addMessageObserver(e3, t2) {
    this.messageObservers[e3] || (this.messageObservers[e3] = [], this.ioSocket.io.on(e3, (t3) => {
      this.notifyMessageObservers(e3, t3);
    })), this.messageObservers[e3].push(new Ns(t2));
  }
  notifyMessageObservers(e3, t2) {
    let s2 = this.messageObservers[e3];
    for (let i2 = 0; i2 < s2.length; i2++)
      s2[i2].onMessage(e3, t2);
  }
};
var Ws = new class {
  validateId(e3, t2) {
    if (es.isEmpty(e3))
      throw { code: 400, content: ` ${t2} is required.` };
    if (!es.isStringOrNumber(e3))
      throw { code: 400, content: `TypeError: ${t2} require string or number.` };
  }
  validateIdArray(e3, t2) {
    if (!Array.isArray(e3) || 0 === e3.length)
      throw { code: 400, content: `TypeError: ${t2} require array.` };
    if (e3.length > 300)
      throw { code: 400, content: `${t2} is over max length 500.` };
    for (let s2 = 0; s2 < e3.length; s2++) {
      if (!es.isStringOrNumber(e3[s2]))
        throw { code: 400, content: `TypeError: ${t2} item require string or number.` };
      if (es.isNumber(e3[s2]) && (e3[s2] = e3[s2].toString()), 0 == e3[s2].length)
        throw { code: 400, content: `${t2} has empty item.` };
    }
    if (Array.from(new Set(e3)).length < e3.length)
      throw { code: 400, content: `Duplicate element in ${t2}` };
  }
  validateChannel(e3, t2) {
    this.validateId(e3, t2);
  }
  validateChannelArray(e3, t2) {
    this.validateIdArray(e3, t2);
  }
  validateChannelAndChannels(e3, t2) {
    let s2 = !es.isEmpty(e3), i2 = !es.isEmpty(t2);
    if (!s2 && !i2)
      throw { code: 400, content: "channel is required." };
    if (s2 && i2)
      throw { code: 400, content: "subscribe to either channel or channels, not both." };
    s2 && this.validateId(e3, "channel"), i2 && this.validateIdArray(t2, "channels");
  }
  validateCallbackOptions(e3) {
    if (!es.isObject(e3))
      throw { code: 400, content: "bad parameters" };
  }
  validateNotification(e3) {
    function t2(e4, t3, s3) {
      if (!(es.isString(e4[t3]) && e4[t3].length <= s3))
        throw { code: 400, content: `notification.${t3} must be a string of no more than ${s3} characters` };
    }
    function s2(e4, t3, s3, i2) {
      let n2 = e4[t3];
      if (es.isObject(n2) && es.isDef(n2[s3])) {
        let e5 = { code: 400, content: `notification.vendorOptions.${t3}.${s3} require a ${i2}}` }, o2 = n2[s3];
        if ("string" === i2 && !es.isString(o2))
          throw e5;
        if ("number" === i2 && !es.isNumber(o2))
          throw e5;
      }
    }
    if (!es.isObject(e3))
      throw { code: 400, content: "TypeError: notification requires an object." };
    {
      if (t2(e3, "title", 32), t2(e3, "body", 50), es.isDef(e3.sound) && !es.isString(e3.sound))
        throw { code: 400, content: "notification.sound must be a string" };
      if (es.isDef(e3.badge) && !es.isString(e3.badge))
        throw { code: 400, content: "notification.badge must be a string" };
      e3.badge = e3.badge || "0";
      let i2 = e3.vendorOptions;
      es.isObject(i2) && (s2(i2, "huawei", "category", "string"), s2(i2, "xiaomi", "channel_id", "string"), s2(i2, "oppo", "channel_id", "string"), s2(i2, "vivo", "classification", "number"), s2(i2, "vivo", "category", "string"));
    }
  }
  validateValIsEmpty(e3, t2) {
    if (es.isUndef(e3) || es.isEmpty(e3))
      throw { code: 400, content: `${t2} is empty` };
  }
  validateWXMPTemplateMsg(e3) {
    if (es.isObject(e3)) {
      if (!es.isString(e3.template_id))
        throw { code: 400, content: "template_id must be string." };
      if (!es.isEmpty(e3.url) && !es.isString(e3.url))
        throw { code: 400, content: "url must be string" };
      if (!(es.isEmpty(e3.miniprogram) || es.isString(e3.miniprogram.appid) && es.isString(e3.miniprogram.pagepath)))
        throw { code: 400, content: "miniprogram.appid and miniprogram.pagepath must be strings." };
      if (!es.isObject(e3.data))
        throw { code: 400, content: "data requires an object." };
    } else if (es.isPrimitive(e3))
      throw { code: 400, content: "wxmpTemplateMsg must be an object." };
  }
}();
function zs(e3) {
  if (null === e3 || "object" != typeof e3 || "isActiveClone" in e3)
    return e3;
  let t2 = e3 instanceof Array ? [] : {};
  for (let s2 in e3)
    "object" == typeof e3[s2] ? t2[s2] = zs(e3[s2]) : t2[s2] = e3[s2];
  return t2;
}
var Xs = class {
  publish(e3) {
    es.isFunction(e3.onFailed) || (e3.onFailed = Ts), es.isFunction(e3.onSuccess) || (e3.onSuccess = Ts), this.validate(e3), e3.channel = e3.channel.toString();
    let t2 = { channel: e3.channel, content: e3.message, nt: e3.notification, at: e3.accessToken, guid: Ms.get(), q: e3.qos };
    e3.wxmpTemplateMsg && (t2.wxmpTemplateMsg = zs(e3.wxmpTemplateMsg), t2.wxmpTemplateMsg.data = JSON.stringify(t2.wxmpTemplateMsg.data));
    let s2 = new As({ name: Os.publish, params: t2, unique: true, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, permission: Jt.WRITE, success: function(t3) {
      e3.onSuccess({ code: 200, content: "ok" });
    }, fail: function(t3) {
      e3.onFailed({ code: t3.resultCode, content: t3.content });
    } });
    Ds.e(s2);
  }
  validate(e3) {
    if (Ws.validateChannel(e3.channel, "channel"), es.isEmpty(e3.message))
      throw { code: 400, content: "message is required." };
    if (!es.isString(e3.message))
      throw { code: 400, content: "TypeError: message requires string." };
    if (e3.message.length > 1e4)
      throw { code: 400, content: "Message over max length 10000." };
    if (e3.qos && !(e3.qos in [0, 1]))
      throw { code: 400, content: "Qos must be 0 or 1." };
    e3.wxmpTemplateMsg && Ws.validateWXMPTemplateMsg(e3.wxmpTemplateMsg), es.isDef(e3.notification) && Ws.validateNotification(e3.notification);
  }
};
var Js = class {
  constructor(e3) {
    if (this.options = e3, this.channels = e3.channels || [e3.channel], !es.isEmpty(e3.channel)) {
      let t2 = e3.channel.toString();
      this.channels = [t2];
    }
    es.isEmpty(e3.channels) || (this.channels = e3.channels.toString().split(","));
  }
};
var Ys;
var Qs;
var $s;
!function(e3) {
  e3.message = "message", e3.imMessage = "imMessage", e3.userPresence = "userPresence", e3.groupPresence = "groupPresence", e3.PS_PRESENCE_EVENT = "PS_PRESENCE_EVENT", e3.IM_MSG_READ = "IM_MSG_READ", e3.IM_MSG_DELETED = "IM_MSG_DELETED", e3.IM_MSG_RECALLED = "IM_MSG_RECALLED", e3.RTC_RING_EVENT = "RTC_RING_EVENT", e3.RTC_CANCEL_RING = "RTC_CANCEL_RING", e3.RTC_REMOTE_USER_LEFT = "RTC_REMOTE_USER_LEFT", e3.RTC_CALL_END = "RTC_CALL_END", e3.CS_ONLINE_CHANGED = "CS_ONLINE_CHANGED";
}(Ys || (Ys = {}));
var Ks = class {
  constructor() {
    this.subscriptions = [], Fs.instance.addAssembler(new class {
      assemble(e3) {
        return { channel: e3.ch, content: e3.ctt };
      }
      support(e3) {
        return !!e3.ch;
      }
    }());
  }
  initialGoEasySocket() {
    Ds.s().addMessageObserver(Ys.message, this.onNewMessage.bind(this)), Ds.s().addExpiredReconnectedObserver(this.expiredResubscribe.bind(this)), Ds.s().addConnectedObserver(this.resubscribePresenceChannel.bind(this));
  }
  clearSubscriptions() {
    this.subscriptions = [];
  }
  expiredResubscribe() {
    this.subscriptions.forEach((e3) => {
      this.doSubscribe(e3, false);
    });
  }
  resubscribePresenceChannel() {
    this.subscriptions.forEach((e3) => {
      let t2 = e3.options;
      t2.presence && t2.presence.enable && this.doSubscribe(e3, true);
    });
  }
  onNewMessage(e3) {
    if (e3.n.indexOf("_presence") > -1)
      return;
    e3.a && Ds.s().sendAck("ack", { publishGuid: e3.i });
    let t2 = { time: e3.t, channel: e3.n, content: e3.c };
    this.createNotification(e3), this.findSubscriptionByChannel(t2.channel).options.onMessage(t2);
  }
  createNotification(e3) {
    const t2 = Fs.instance.supportNotification();
    if (!es.isObject(e3.nt) || !t2)
      return;
    const s2 = { ch: e3.n, ctt: e3.c };
    Fs.instance.createLocalNotification(e3.nt.t, e3.nt.c, s2, e3.nt.sound, e3.nt.badge);
  }
  subscribe(e3) {
    if (Ws.validateChannelAndChannels(e3.channel, e3.channels), es.isDef(e3.presence)) {
      let t3 = e3.presence.enable;
      if (!es.isBoolean(t3))
        throw { code: 400, content: "Subscription failed. presence.enable must be a boolean" };
      if (t3 && Ds.s().anonymous)
        throw { code: 400, content: "Subscription failed. If presence is enable, the id must be specified when calling the connect method" };
    }
    let t2 = new Js(e3);
    this.doSubscribe(t2, false).then(() => {
      this.subscriptions.push(t2), xs.onSuccess(e3, { code: 200, content: "ok" });
    }).catch((t3) => {
      xs.onFailed(e3, { code: t3.resultCode, content: t3.content });
    });
  }
  doSubscribe(e3, t2) {
    let s2 = e3.options;
    return new Promise((i2, n2) => {
      let o2 = new As({ name: Os.subscribe, permission: Jt.READ, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, params: { channels: e3.channels, accessToken: s2.accessToken, presence: s2.presence, resubscribe: t2 }, success: () => {
        i2();
      }, fail: (e4) => {
        n2(e4);
      } });
      Ds.e(o2);
    });
  }
  unsubscribe(e3) {
    Ws.validateChannel(e3.channel, "channel"), e3.channel = e3.channel.toString();
    const t2 = this.findSubscriptionByChannel(e3.channel);
    if (!t2)
      return void e3.onFailed({ code: 400, content: "channel[" + e3.channel + "] is not subscribed" });
    let s2 = new As({ name: Os.unsubscribe, params: { channel: e3.channel, presence: t2.options.presence }, permission: Jt.READ, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: () => {
      e3.onSuccess({ code: 200, content: "ok" }), this.removeChannel(e3.channel);
    }, fail: function(t3) {
      e3.onFailed({ code: t3.resultCode, content: t3.content });
    } });
    Ds.e(s2);
  }
  removeChannel(e3) {
    for (let t2 = this.subscriptions.length - 1; t2 >= 0; t2--) {
      const s2 = this.subscriptions[t2].channels, i2 = s2.indexOf(e3);
      if (i2 > -1) {
        s2.splice(i2, 1), 0 === s2.length && this.subscriptions.splice(t2, 1);
        break;
      }
    }
  }
  findSubscriptionByChannel(e3) {
    let t2 = false, s2 = null;
    for (let i2 = this.subscriptions.length - 1; i2 >= 0; i2--) {
      let n2 = this.subscriptions[i2].channels;
      for (let o2 = 0; o2 < n2.length; o2++)
        if (n2[o2] == e3) {
          t2 = true, s2 = this.subscriptions[i2];
          break;
        }
      if (t2)
        break;
    }
    return s2;
  }
};
var Zs = class {
  get(e3) {
    es.isFunction(e3.onSuccess) || (e3.onSuccess = Ts), es.isFunction(e3.onFailed) || (e3.onFailed = Ts), Ws.validateChannel(e3.channel, "channel"), e3.channel = e3.channel.toString();
    let t2 = new As({ name: Os.historyMessages, permission: Jt.READ, params: e3, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, success: (t3) => {
      e3.onSuccess({ code: t3.resultCode || t3.code || 200, content: t3.content });
    }, fail: (t3) => {
      e3.onFailed({ code: t3.resultCode || t3.code, content: t3.content });
    } });
    Ds.e(t2);
  }
};
var ei = class {
  constructor() {
    this.channelPresenceMap = /* @__PURE__ */ new Map(), Ds.s().addDisconnectedObserver(this.expireAllChannelPresences.bind(this)), Ds.s().addConnectedObserver(this.resubscribe.bind(this)), Ds.s().addMessageObserver(Ys.PS_PRESENCE_EVENT, this.onPresenceEvent.bind(this));
  }
  hereNow(e3) {
    let t2, s2 = this.channelPresenceMap.get(e3.channel);
    s2 && s2.queryPromise ? (e3.limit && e3.limit > s2.membersLimit && s2.doQuery(e3.limit), t2 = s2.queryPromise) : t2 = si(e3.channel, e3.limit), t2.then((t3) => {
      e3.onSuccess(t3);
    }).catch((t3) => {
      e3.onFailed(t3);
    });
  }
  subscribe(e3) {
    if (es.isUndef(e3.onPresence) || !es.isFunction(e3.onPresence))
      throw { code: 400, content: "Subscription Presence failed. onPresence callback function is required" };
    let t2 = e3.channel, s2 = this.channelPresenceMap.get(t2);
    s2 || (s2 = new ti(t2), this.channelPresenceMap.set(t2, s2)), s2.subscribe(e3);
  }
  unsubscribe(e3) {
    let t2 = e3.channel;
    if (this.channelPresenceMap.get(t2)) {
      let s2 = new As({ name: Os.PUBSUB_PRESENCE_UNSUBSCRIBE, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, params: { channel: t2 }, success: (s3) => {
        this.channelPresenceMap.delete(t2), e3.onSuccess();
      }, fail: (t3) => {
        e3.onFailed(t3);
      } });
      Ds.e(s2);
    } else
      e3.onSuccess();
  }
  onPresenceEvent(e3) {
    this.channelPresenceMap.get(e3.channel).onPresence(e3);
  }
  expireAllChannelPresences() {
    this.channelPresenceMap.forEach((e3, t2) => {
      e3.expire();
    });
  }
  resubscribe() {
    this.channelPresenceMap.forEach((e3, t2) => {
      e3.subscribed() && e3.doSubscribe();
    });
  }
};
var ti = class {
  constructor(e3) {
    this.membersLimit = 10, this.queried = false, this.channel = e3;
  }
  onPresence(e3) {
    return t(this, void 0, void 0, function* () {
      this.queried ? this.update(e3) : yield this.queryPromise, this.on({ channel: this.channel, action: e3.action, member: e3.member, time: e3.time, amount: this.amount, members: this.membersByLimit() });
    });
  }
  membersByLimit() {
    return this.members.slice(0, this.membersLimit);
  }
  subscribe(e3) {
    return t(this, void 0, void 0, function* () {
      if (!this.subscribed())
        try {
          yield this.doSubscribe();
        } catch (t2) {
          return void e3.onFailed(t2);
        }
      this.on = e3.onPresence, e3.membersLimit && (this.membersLimit = e3.membersLimit), e3.onSuccess();
    });
  }
  doSubscribe() {
    return this.doQuery(this.membersLimit), new Promise((e3, t2) => {
      let s2 = new As({ name: Os.PUBSUB_PRESENCE_SUBSCRIBE, permission: Jt.READ, params: { channel: this.channel }, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: (t3) => {
        e3();
      }, fail: (e4) => {
        t2(e4);
      } });
      Ds.e(s2);
    });
  }
  doQuery(e3) {
    this.queryPromise = si(this.channel, e3), this.queryPromise.then((e4) => {
      this.members = e4.content.members, this.amount = e4.content.amount, this.queried = true;
    }).catch((e4) => {
      throw e4;
    });
  }
  update(e3) {
    if (["join", "back"].includes(e3.action))
      this.members.unshift(e3.member);
    else if (["leave", "timeout"].includes(e3.action)) {
      let t2 = this.members.findIndex((t3) => t3.id === e3.member.id);
      t2 > -1 && this.members.splice(t2, 1);
    }
    this.amount = e3.amount;
  }
  expire() {
    this.queried = false, this.queryPromise = null;
  }
  subscribed() {
    return void 0 !== this.on;
  }
};
function si(e3, t2) {
  return t2 || (t2 = 10), new Promise((s2, i2) => {
    let n2 = { channel: e3, limit: t2 }, o2 = new As({ name: Os.PUBSUB_PRESENCE_HERENOW, permission: Jt.READ, params: n2, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, success: (e4) => {
      s2(e4);
    }, fail: (e4) => {
      i2(e4);
    } });
    Ds.e(o2);
  });
}
var ii = class _ii {
  constructor(e3) {
    this.subscriber = new Ks(), this.options = e3;
  }
  static init(e3) {
    _ii.instance = new _ii(e3);
  }
  initialGoEasySocket() {
    this.publisher = new Xs(), this.histories = new Zs(), this.subscriber.initialGoEasySocket(), this.presence2 = new ei();
  }
  initialBeforeConnect() {
    this.subscriber.clearSubscriptions();
  }
  catch(e3, t2) {
    try {
      this.validateOptions(), e3();
    } catch (e4) {
      xs.onFailed(t2, e4);
    }
  }
  validateOptions() {
    if (!Ds.s() || [e.DISCONNECTED, e.DISCONNECTING, e.CONNECT_FAILED].includes(Ds.s().getStatus()))
      throw Error("Please call connect() first.");
    if (!this.options.modules || !this.options.modules.includes(Ps))
      throw { code: 400, content: `Invalid options: module '${Ps}' is not enabled` };
  }
  publish(e3) {
    this.catch(() => {
      this.publisher.publish(e3);
    }, e3);
  }
  subscribe(e3) {
    this.catch(() => {
      this.subscriber.subscribe(e3);
    }, e3);
  }
  unsubscribe(e3) {
    this.catch(() => {
      this.subscriber.unsubscribe(e3);
    }, e3);
  }
  subscribePresence(e3) {
    this.catch(() => {
      this.presence2.subscribe(e3);
    }, e3);
  }
  unsubscribePresence(e3) {
    this.catch(() => {
      this.presence2.unsubscribe(e3);
    }, e3);
  }
  history(e3) {
    this.catch(() => {
      this.histories.get(e3);
    }, e3);
  }
  hereNow(e3) {
    this.catch(() => {
      this.presence2.hereNow(e3);
    }, e3);
  }
};
!function(e3) {
  e3.PRIVATE_MESSAGE_RECEIVED = "PRIVATE_MESSAGE_RECEIVED", e3.GROUP_MESSAGE_RECEIVED = "GROUP_MESSAGE_RECEIVED", e3.SYSTEM_MESSAGE_RECEIVED = "SYSTEM_MESSAGE_RECEIVED", e3.CONVERSATIONS_UPDATED = "CONVERSATIONS_UPDATED", e3.USER_PRESENCE = "USER_PRESENCE", e3.GROUP_PRESENCE = "GROUP_PRESENCE", e3.MESSAGE_DELETED = "MESSAGE_DELETED", e3.MESSAGE_READ = "MESSAGE_READ", e3.MESSAGE_RECALLED = "MESSAGE_RECALLED", e3.CS_MESSAGE_RECEIVED = "CS_MESSAGE_RECEIVED", e3.PENDING_CONVERSATIONS_UPDATED = "PENDING_CONVERSATIONS_UPDATED";
}(Qs || (Qs = {})), function(e3) {
  e3.RING = "RING", e3.USER_ACCEPTED = "USER_ACCEPTED", e3.CALL_ENDED = "CALL_ENDED", e3.USER_QUITED = "USER_QUITED";
}($s || ($s = {}));
var ni = S.exports;
var oi = class {
  constructor() {
    this.emitter = new ni();
  }
  on(e3, t2) {
    if (!es.isString(e3))
      throw Error("event require a string.");
    if (!es.isDef(Qs[e3]) && !es.isDef($s[e3]))
      throw Error("An event that is not defined");
    if (!es.isFunction(t2))
      throw Error("callback must be a function");
    this.emitter.on(e3, t2);
  }
  fire(e3, t2) {
    this.emitter.emit(e3, t2);
  }
  off(e3, t2) {
    this.emitter.off(e3, t2);
  }
};
var ri = class {
  constructor() {
  }
};
var ai = new class extends ri {
  constructor() {
    super();
  }
  upload(e3, t2) {
    try {
      return delete e3.parameters.fileRes, new Promise((s2, i2) => {
        uni.uploadFile({ url: e3.host, filePath: this.getTempFilePath(e3), name: "file", formData: e3.parameters, success(e4) {
          200 === e4.statusCode ? s2() : i2({ code: e4.statusCode, content: e4.errMsg });
        }, fail(e4) {
          i2({ code: 500, content: e4.errMsg });
        } }).onProgressUpdate((e4) => {
          t2 && t2(e4);
        });
      });
    } catch (e4) {
      return new Promise((t3, s2) => {
        s2({ code: 500, content: e4 });
      });
    }
  }
  getTempFilePath(e3) {
    let t2 = e3.file;
    return t2.tempFilePath || t2.fullPath || t2.path;
  }
}();
var ci = new class extends ri {
  upload(e3, t2) {
    try {
      return new Promise((s2, i2) => {
        wx.uploadFile({ url: e3.host, filePath: this.getTempFilePath(e3), name: "file", formData: e3.parameters, success(e4) {
          200 === e4.statusCode ? s2() : i2({ code: e4.statusCode, content: e4.errMsg });
        }, fail(e4) {
          i2({ code: 500, content: e4.errMsg });
        } }).onProgressUpdate((e4) => {
          t2 && t2(e4);
        });
      });
    } catch (e4) {
      return new Promise((t3, s2) => {
        s2({ code: 500, content: e4 });
      });
    }
  }
  getTempFilePath(e3) {
    let t2 = e3.file || e3.fileRes;
    return t2.path || t2.tempFilePath;
  }
}();
var ui = new class extends ri {
  constructor() {
    super();
  }
  upload(e3, t2) {
    try {
      return new Promise((s2, i2) => {
        let n2 = new XMLHttpRequest();
        n2.open("post", e3.host, true);
        for (let t3 in e3.headers)
          n2.setRequestHeader(t3, e3.headers[t3]);
        n2.upload.onprogress = function(e4) {
          t2 && t2(e4);
        }, n2.upload.onloadstart = function(e4) {
          t2 && t2(e4);
        }, n2.upload.onloadend = function(e4) {
          t2 && t2(e4);
        };
        let o2 = new FormData();
        for (let t3 in e3.parameters)
          "fileRes" == t3 ? o2.append("file", e3.parameters[t3]) : o2.append(t3, e3.parameters[t3]);
        n2.send(o2), n2.onreadystatechange = function() {
          4 == n2.readyState && (n2.status >= 200 && n2.status < 300 || 304 == n2.status ? s2() : i2({ code: n2.status, content: n2.responseText }));
        };
      });
    } catch (e4) {
      return new Promise((t3, s2) => {
        s2({ code: 500, content: e4 });
      });
    }
  }
}();
var li = class {
  constructor(e3, t2, s2) {
    this.storageLocation = e3, this.url = t2, this.name = s2;
  }
};
var di = new class {
  constructor() {
    this.uploader = { [Ct.UNIAPP]: ai, [Ct.NATIVE_APPLET_WX]: ci, [Ct.TARO]: It.currentPlatform() === vt.APPLET_WX ? ci : ui, [Ct.UNKNOWN]: ui };
  }
  upload(e3, s2) {
    return t(this, void 0, void 0, function* () {
      const t2 = Mt.currentFramework();
      let i2 = this.uploader[t2];
      return yield i2.upload(e3, s2), new li(e3.storageLocation, e3.url, e3.newFileName);
    });
  }
}();
var hi = class {
  resolve(e3) {
    return new Promise((t2, s2) => {
      let i2 = new As({ name: "uploadToken", params: { filename: e3 }, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail(e4) {
        s2(e4.content);
      }, success(e4) {
        200 === e4.code ? t2(e4.content) : s2(e4.content);
      } });
      Ds.e(i2);
    });
  }
};
var pi;
!function(e3) {
  e3.aliYun = "ALI", e3.qiNiu = "QN", e3.tencent = "TX";
}(pi || (pi = {}));
var mi = class {
  constructor(e3, t2, s2, i2, n2, o2, r2) {
    this.storageLocation = e3, this.host = t2, this.headers = s2, this.parameters = i2, this.file = n2, this.newFileName = o2, this.url = r2;
  }
};
var fi = class {
  constructor() {
  }
  newFileName(e3) {
    return e3 && e3.newFilename || "";
  }
};
var gi = new class extends fi {
  constructor() {
    super();
  }
  url(e3) {
    return e3.host + "/" + e3.dir + "/" + this.newFileName(e3);
  }
  build(e3, t2, s2) {
    let i2, n2 = this.newFileName(e3);
    return i2 = { key: e3.dir + "/" + n2, OSSAccessKeyId: e3.accessKeyId, policy: e3.policy, signature: e3.signature, success_action_status: "200", fileRes: t2 }, s2 && (i2 = { key: e3.dir + "/" + n2, OSSAccessKeyId: e3.accessKeyId, policy: e3.policy, signature: e3.signature, success_action_status: "200", "Content-Disposition": "attachment;filename=" + t2.name, fileRes: t2 }), new mi(pi.aliYun, e3.host, null, i2, t2, n2, this.url(e3));
  }
}();
var yi = new class extends fi {
  constructor() {
    super();
  }
  url(e3) {
    return e3.host + "/" + e3.key;
  }
  build(e3, t2, s2) {
    let i2 = { "q-sign-algorithm": e3.qSignAlgorithm, "q-ak": e3.qAk, "q-key-time": e3.qKeyTime, "q-signature": e3.qSignature, policy: e3.policy, "x-cos-security-token": e3.xCosSecurityToken, success_action_status: "200", key: e3.key, fileRes: t2 };
    return s2 && (i2 = { "q-sign-algorithm": e3.qSignAlgorithm, "q-ak": e3.qAk, "q-key-time": e3.qKeyTime, "q-signature": e3.qSignature, policy: e3.policy, "x-cos-security-token": e3.xCosSecurityToken, success_action_status: "200", key: e3.key, "Content-Disposition": `attachment;filename=${t2.name}`, fileRes: t2 }), new mi(pi.tencent, e3.host, null, i2, t2, e3.key, this.url(e3));
  }
}();
var Ei = class {
  constructor() {
    this.uploadTokenResolver = new hi();
  }
  builder(e3) {
    if (e3 === pi.aliYun)
      return gi;
    if (e3 === pi.tencent)
      return yi;
    throw new Error("Only Ali OSS and Tencent COS are supported, unknown storage location:" + e3);
  }
  build(e3, s2, i2) {
    return t(this, void 0, void 0, function* () {
      try {
        let t2 = yield this.uploadTokenResolver.resolve(s2), n2 = this.builder(t2.vendor).build(t2, e3, i2);
        return Promise.resolve(n2);
      } catch (e4) {
        return Promise.reject(e4);
      }
    });
  }
};
var vi = class {
  constructor() {
    this.requestBuilder = new Ei(), this.fileUploader = di;
  }
  upload(e3, s2, i2, n2) {
    return t(this, void 0, void 0, function* () {
      try {
        let t2 = yield this.requestBuilder.build(e3, s2, n2);
        return this.fileUploader.upload(t2, i2);
      } catch (e4) {
        return Promise.reject(e4);
      }
    });
  }
};
var Ci = class {
};
var Si;
var bi;
var wi;
!function(e3) {
  e3.TEXT = "text", e3.IMAGE = "image", e3.FILE = "file", e3.VIDEO = "video", e3.AUDIO = "audio";
}(Si || (Si = {}));
var Ii = class extends Ci {
  constructor() {
    super(...arguments), this.goEasyUploader = new vi();
  }
  improve(e3) {
    let t2 = e3.message;
    return new Promise((e4, s2) => {
      let i2, n2, o2 = t2.buildOptions.createOptions;
      t2.type === Si.VIDEO ? (n2 = t2.payload, i2 = n2.video.name) : (n2 = t2.payload, i2 = n2.name), this.goEasyUploader.upload(o2.file, i2, o2.onProgress, t2.type === Si.FILE).then((s3) => {
        this.setPayload(s3, t2), e4();
      }).catch((e5) => {
        s2(e5);
      });
    });
  }
  setPayload(e3, t2) {
    t2.payload.url = e3.url;
  }
};
var Mi = class extends Ii {
  setPayload(e3, t2) {
    let s2, i2 = t2.payload;
    switch (i2.video.url = e3.url, i2.video.name = e3.name, i2.thumbnail.height > 200 && (i2.thumbnail.height = 200, i2.thumbnail.width = 200 * i2.video.width / i2.video.height), e3.storageLocation) {
      case pi.aliYun:
        s2 = "?x-oss-process=video/snapshot,t_0000,f_jpg,h_" + i2.thumbnail.height + ",m_fast,ar_auto";
        break;
      case pi.tencent:
        s2 = "?ci-process=snapshot&time=1&format=jpg&height=" + i2.thumbnail.height;
        break;
      default:
        throw new Error("Only Ali OSS and Tencent COS are supported, unknown storage location:" + e3.storageLocation);
    }
    i2.thumbnail.url = e3.url + s2;
  }
};
var Ai = class extends Ii {
  setPayload(e3, t2) {
    let s2, i2 = t2.payload;
    i2.url = e3.url;
    const n2 = i2.height > 200 ? 200 : i2.height;
    switch (e3.storageLocation) {
      case pi.aliYun:
        s2 = "?x-oss-process=image/resize,m_lfit,h_" + n2;
        break;
      case pi.tencent:
        s2 = `?imageMogr2/thumbnail/x${n2}`;
        break;
      default:
        throw new Error("Only Ali OSS and Tencent COS are supported, unknown storage location:" + e3.storageLocation);
    }
    i2.thumbnail = e3.url + s2;
  }
};
var Ti = class {
  constructor() {
    this.improvers = { [Si.FILE]: new Ii(), [Si.AUDIO]: new Ii(), [Si.IMAGE]: new Ai(), [Si.VIDEO]: new Mi() };
  }
  improve(e3) {
    let t2 = this.improvers[e3.message.type];
    if (t2)
      try {
        return t2.improve(e3);
      } catch (e4) {
        return Promise.reject(e4);
      }
    return Promise.resolve();
  }
};
var Ni = class {
  constructor(e3, t2, s2, i2, n2) {
    this.validate(e3), this.mt = e3.type, this.to = t2.id.toString(), this.d = JSON.stringify(t2.data), this.p = JSON.stringify(e3.payload), s2 && (this.nt = s2), n2 && (this.at = n2), i2 && (this.wxmpTemplateMsg = zs(i2), this.wxmpTemplateMsg.data = JSON.stringify(this.wxmpTemplateMsg.data));
    let o2 = t2.type;
    if (this.t = o2, o2 === lo.CS) {
      let t3 = e3;
      this.tid = t3.teamId;
    }
    this.guid = e3.messageId;
  }
  validate(e3) {
    if (e3.type === Si.TEXT) {
      if (JSON.stringify(e3.payload).length > 3072)
        throw Error("message-length limit 3kb");
    }
  }
};
!function(e3) {
  e3.MESSAGE_SENDING = "IM_INTERNAL_MESSAGE_SENDING", e3.MESSAGE_SEND_SUCCESS = "IM_INTERNAL_MESSAGE_SEND_SUCCESS", e3.MESSAGE_SEND_FAILED = "IM_INTERNAL_MESSAGE_SEND_FAILED", e3.MESSAGE_RECEIVED = "IM_INTERNAL_MESSAGE_RECEIVED", e3.MESSAGE_RECALLED = "IM_INTERNAL_MESSAGE_RECALLED", e3.MAX_MESSAGE_CHANGED = "IM_INTERNAL_MAX_MESSAGE_CHANGED", e3.MAX_MESSAGE_DELETED = "IM_INTERNAL_MAX_MESSAGE_DELETED", e3.UNREAD_AMOUNT_CHANGED = "IM_INTERNAL_UNREAD_MESSAGE_CHANGED", e3.CS_ONLINE_SUCCESS = "CS_ONLINE_SUCCESS", e3.CS_OFFLINE_SUCCESS = "CS_OFFLINE_SUCCESS", e3.CS_ACCEPTED = "CS_ACCEPTED", e3.CS_ENDED = "CS_ENDED", e3.CS_TRANSFER = "CS_TRANSFER", e3.CS_AGENT_MESSAGE_RECEIVED = "CS_AGENT_MESSAGE_RECEIVED";
}(bi || (bi = {}));
var Ri = class {
  clearUseLessAttribute() {
    delete this.buildOptions;
  }
  isOtherSent() {
    return this.senderId !== Ds.u();
  }
  getToData() {
    return this.buildOptions.createOptions.to.data;
  }
};
var Oi = class {
  constructor() {
    this.payloadImprover = new Ti();
  }
  send(e3) {
    this.validate(e3);
    let s2 = e3.message, i2 = e3.accessToken, n2 = s2.buildOptions, o2 = n2.createOptions, r2 = o2.notification, a2 = o2.wxmpTemplateMsg, c2 = o2.to;
    c2.data || (c2.data = {}), s2.status = ho.SENDING;
    let u2 = n2.complete, l2 = this.payloadImprover.improve(e3);
    Promise.all([u2, l2]).then(() => t(this, void 0, void 0, function* () {
      if (o2.beforeSend) {
        const e4 = JSON.parse(JSON.stringify(s2));
        yield o2.beforeSend(e4);
      }
      this.doSend(s2, c2, r2, a2, i2, e3);
    })).catch((t2) => {
      s2.status = ho.FAIL, xs.onFailed(e3, { code: t2 && t2.code || 400, content: t2 && t2.content || t2 });
    });
  }
  doSend(e3, t2, s2, i2, n2, o2) {
    let r2 = new Ni(e3, t2, s2, i2, n2);
    Gs.fire(bi.MESSAGE_SENDING, e3);
    let a2 = new As({ name: Os.publishIM, params: r2, unique: true, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (t3) => {
      e3.status = ho.FAIL, Gs.fire(bi.MESSAGE_SEND_FAILED, e3), xs.onFailed(o2, { code: t3.resultCode, content: t3.content });
    }, success: (t3) => {
      if (e3.status = ho.SUCCESS, e3.timestamp = t3.content.timestamp, e3.scene() === lo.CS) {
        let s3 = e3;
        s3.customerId() !== Ds.u() && (s3.sessionId = t3.content.sessionId);
      }
      e3.clearUseLessAttribute(), Gs.fire(bi.MESSAGE_SEND_SUCCESS, e3), xs.onSuccess(o2, e3);
    } });
    Ds.e(a2);
  }
  validate(e3) {
    let t2 = e3.message;
    if (!(t2 instanceof Ri))
      throw new Error("it is invalid message");
    if (t2.status !== ho.NEW)
      throw new Error("Please create a new message, a message can only be sent once");
  }
};
var _i = class {
  insert(e3, t2) {
    let s2 = this.binarySearch(e3, t2);
    if (s2 >= 0)
      e3.splice(s2, 1, t2);
    else {
      let i2 = -s2 - 1;
      e3.splice(i2, 0, t2);
    }
  }
  binarySearch(e3, t2) {
    let s2 = 0, i2 = e3.length - 1;
    for (; s2 <= i2; ) {
      let n2 = i2 + s2 >> 1, o2 = this.compare(t2, e3[n2]);
      if (o2 > 0)
        s2 = n2 + 1;
      else {
        if (!(o2 < 0))
          return n2;
        i2 = n2 - 1;
      }
    }
    return -s2 - 1;
  }
};
var Pi = class _Pi {
  constructor(e3) {
    this.messages = new Array(), this.allLoaded = false, this.target = e3;
  }
  all() {
    return this.messages;
  }
  sliceOverLengthMessages() {
    this.messages.length > _Pi.CACHE_MAX_LENGTH && (this.messages = this.messages.slice(-_Pi.CACHE_MAX_LENGTH), true === this.allLoaded && (this.allLoaded = false));
  }
  getMaxMessage() {
    return this.messages[this.messages.length - 1];
  }
  loadLocalMessages(e3, t2) {
    let s2 = [], i2 = this.messages.length;
    if (t2) {
      if (i2 > 0) {
        let n2 = this.messages[0].timestamp, o2 = this.messages[i2 - 1].timestamp;
        if (t2 >= n2 && t2 <= o2)
          for (let n3 = i2 - 1; n3 >= 0; n3--) {
            let i3 = this.messages[n3];
            if (i3.timestamp < t2) {
              if (!(s2.length < e3))
                break;
              s2.unshift(i3);
            }
          }
      }
    } else
      s2 = this.messages.slice(-e3);
    return s2;
  }
  cacheServerMessages(e3, t2) {
    let s2 = this.messages[0];
    this.messages.length < _Pi.CACHE_MAX_LENGTH && (!e3.lastTimestamp || this.messages.length > 0 && s2.timestamp === e3.lastTimestamp) && (t2.forEach((e4) => {
      _Pi.sortedInserter.insert(this.messages, e4);
    }), t2.length < e3.limit && (this.allLoaded = true));
  }
  findMessageByTime(e3) {
    return this.messages.find((t2) => e3 === t2.timestamp);
  }
  findMessagesByTimes(e3) {
    let t2 = [];
    return e3.forEach((e4) => {
      let s2 = this.findMessageByTime(e4);
      es.isDef(s2) && t2.push(s2);
    }), t2;
  }
  existsMessage(e3) {
    return this.findMessageIndexById(e3) > -1;
  }
  findMessageIndexById(e3) {
    return this.messages.findIndex((t2) => e3 === t2.messageId);
  }
  deleteMessage(e3) {
    let t2 = this.findMessageIndexById(e3);
    t2 >= 0 && this.messages.splice(t2, 1);
  }
  recallMessage(e3) {
    return e3.times.map((e4) => this.findMessageByTime(e4)).filter((e4) => es.isDef(e4)).map((t2) => (t2.recalled = true, t2.recaller = e3.recaller, t2));
  }
  isEmpty() {
    return 0 === this.messages.length;
  }
  deleteMessages(e3) {
    e3.forEach((e4) => {
      this.deleteMessage(e4.messageId);
    });
  }
  saveMessage(e3) {
    _Pi.sortedInserter.insert(this.messages, e3), this.sliceOverLengthMessages();
  }
  maxSuccessMessageTime() {
    for (let e3 = this.messages.length - 1; e3 >= 0; e3--)
      if (this.messages[e3].status === ho.SUCCESS)
        return this.messages[e3].timestamp;
    return 0;
  }
  minTime() {
    return this.isEmpty() ? 0 : this.messages[0].timestamp;
  }
  correctPosition(e3) {
    this.deleteMessage(e3.messageId), this.saveMessage(e3);
  }
};
Pi.CACHE_MAX_LENGTH = 200, Pi.sortedInserter = new class extends _i {
  compare(e3, t2) {
    let s2 = e3.timestamp - t2.timestamp;
    return s2 > 0 ? 1 : 0 === s2 ? 0 : -1;
  }
}();
var ki = class _ki {
  constructor(e3, t2, s2) {
    this.scene = e3, this.id = t2, es.isDef(s2) && (this.teamId = s2);
  }
  toString() {
    return lo.PRIVATE === this.scene || lo.GROUP === this.scene ? this.scene + "#" + this.id : this.scene + "#" + this.id + "#" + this.teamId;
  }
  customerId() {
    if (lo.CS === this.scene)
      return this.id === this.teamId ? Ds.u() : this.id;
  }
  static byScene(e3, t2, s2) {
    return new _ki(e3, t2, s2);
  }
  static byIMMessage(e3) {
    let t2, s2, i2 = e3.scene();
    if (i2 === lo.PRIVATE) {
      let t3 = e3.senderId, i3 = e3.targetId();
      s2 = Ds.u() === t3 ? i3 : t3;
    } else if (i2 === lo.GROUP)
      s2 = e3.targetId();
    else {
      if (i2 !== lo.CS)
        throw { code: 400, content: `scene ${i2} not exists` };
      s2 = e3.targetId(), t2 = e3.teamId;
    }
    return new _ki(i2, s2, t2);
  }
  static byMessageReadRemoteEvent(e3) {
    let t2, s2 = e3.scene, i2 = e3.targetId, n2 = e3.markerId, o2 = e3.teamId;
    return s2 === lo.PRIVATE ? t2 = Ds.u() === n2 ? i2 : n2 : s2 === lo.GROUP ? t2 = i2 : s2 === lo.CS && (t2 = i2 === o2 ? n2 === Ds.u() ? o2 : n2 : n2 === Ds.u() ? i2 : o2), new _ki(s2, t2, o2);
  }
  static byIMMessageDeletedEvent(e3) {
    let t2 = e3.scene, s2 = e3.deleterId;
    if (t2 === lo.PRIVATE) {
      let i2 = Ds.u() === s2 ? e3.targetId : s2;
      return new _ki(t2, i2);
    }
    if (t2 === lo.GROUP)
      return new _ki(t2, e3.targetId);
  }
  static byConversationDTO(e3) {
    let t2 = e3.lastMessage;
    return this.byIMMessage(t2);
  }
  static byConversationId(e3, t2) {
    let s2;
    if (e3 === lo.PRIVATE) {
      let e4 = t2.split(":", 2);
      s2 = e4[0] === Ds.u() ? e4[1] : e4[0];
    } else
      s2 = t2;
    return new _ki(e3, s2);
  }
};
var Di = class {
  constructor(e3) {
    this.times = new Array();
    let t2 = e3[0], s2 = ki.byIMMessage(t2);
    this.scene = s2.scene, this.targetId = s2.id, e3.forEach((e4) => {
      e4.status === ho.SUCCESS && this.times.push(e4.timestamp);
    }), this.times.sort((e4, t3) => e4 < t3 ? -1 : e4 == t3 ? 0 : 1);
  }
};
var xi = class {
  static deleteServerMessages(e3) {
    let t2 = new Di(e3);
    return t2.times.length < 0 ? Promise.resolve() : new Promise((e4, s2) => {
      let i2 = new As({ name: Os.IM_DELETE_MESSAGE, params: t2, permission: Jt.WRITE, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, success: (t3) => {
        200 === t3.code ? e4(t3) : s2(t3);
      }, fail: (e5) => {
        s2(e5);
      } });
      Ds.e(i2);
    });
  }
  static validate(e3) {
    let t2 = e3.messages;
    for (let e4 = 0; e4 < t2.length; e4++) {
      let s2 = t2[e4];
      if (s2.status === ho.SENDING)
        throw { code: 400, content: "message[" + e4 + "] is '" + s2.status + "' and cannot be deleted" };
    }
  }
};
var Fi = class {
  constructor(e3, t2, s2, i2, n2) {
    this.scene = e3, this.id = t2, this.after = s2, this.min = i2, this.teamId = n2;
  }
};
var Ui = class {
  constructor(e3, t2, s2, i2) {
    this.id = e3, this.scene = t2, this.lastTimestamp = s2, this.teamId = i2;
  }
};
var Li = class extends Ri {
  constructor() {
    super(...arguments), this.read = false;
  }
  scene() {
    return lo.PRIVATE;
  }
  targetId() {
    return this.receiverId;
  }
};
var Gi = class extends Ri {
  scene() {
    return lo.GROUP;
  }
  targetId() {
    return this.groupId;
  }
};
var Bi = class extends Ri {
  constructor() {
    super(...arguments), this.accepted = false;
  }
  scene() {
    return lo.CS;
  }
  targetId() {
    return Ds.u() === this.customerId() ? this.teamId : this.customerId();
  }
  sendByCustomer() {
    return this.to === this.teamId;
  }
  customerId() {
    return this.sendByCustomer() ? this.senderId : this.to;
  }
  isOtherSent() {
    return Ds.u() === this.customerId() ? this.senderId !== Ds.u() : this.senderId === this.customerId();
  }
};
!function(e3) {
  e3.ACCEPT = "CS_ACCEPT", e3.END = "CS_END", e3.TRANSFER = "CS_TRANSFER";
}(wi || (wi = {}));
var qi = class {
  build(e3) {
    let t2, s2 = e3.t;
    s2 === lo.PRIVATE ? (t2 = new Li(), t2.read = false, t2.receiverId = e3.r) : s2 === lo.GROUP ? (t2 = new Gi(), t2.groupId = e3.r, t2.senderData = e3.d ? JSON.parse(e3.d) : {}) : s2 === lo.CS && (t2 = new Bi(), t2.to = e3.r, t2.teamId = e3.tid, t2.senderData = e3.d ? JSON.parse(e3.d) : {}, t2.accepted = e3.accepted, t2.customerId() !== Ds.u() && (t2.sessionId = e3.sessionId)), t2.senderId = e3.s, t2.messageId = e3.i, t2.timestamp = e3.ts, t2.type = e3.mt;
    let i2 = e3.p;
    if (es.isDef(i2))
      if (s2 === lo.CS && t2.type === wi.TRANSFER) {
        let e4 = JSON.parse(i2);
        e4.transferTo.data = JSON.parse(e4.transferTo.data), t2.payload = e4;
      } else
        t2.payload = JSON.parse(i2);
    let n2 = e3.rc;
    return es.isDef(n2) && true === n2 ? (t2.recalled = n2, t2.recaller = e3.recaller) : t2.recalled = false, t2.status = ho.SUCCESS, t2;
  }
};
var ji = class {
  constructor() {
    this.builder = new qi();
  }
  sync(e3, t2, s2, i2, n2) {
    let o2 = new Fi(e3, t2, s2, i2, n2);
    return new Promise((e4, t3) => {
      let s3 = new As({ name: Os.IM_HISTORY_CHANGE, params: o2, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e5) => {
        t3(e5);
      }, success: (t4) => {
        let s4 = t4.content;
        e4(s4);
      } });
      Ds.e(s3);
    });
  }
  loadServerMessages(e3, t2) {
    return new Promise((s2, i2) => {
      let n2 = new As({ name: Os.IM_HISTORY, params: t2, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e4) => {
        i2(e4);
      }, success: (t3) => {
        let i3 = t3.content;
        i3.messages = this.convertServerMessages(e3, i3.messages), s2(i3);
      } });
      Ds.e(n2);
    });
  }
  convertServerMessages(e3, t2) {
    let s2 = [], i2 = e3.scene, n2 = e3.id;
    return t2.forEach((t3) => {
      if (t3.t = i2, lo.PRIVATE === i2)
        t3.r = t3.s === Ds.u() ? n2 : Ds.u();
      else if (lo.GROUP === i2)
        t3.r = n2;
      else if (lo.CS === i2) {
        let s3 = e3.customerId(), i3 = e3.teamId;
        s3 === Ds.u() ? t3.r = i3 : t3.r = s3;
      }
      let o2 = this.builder.build(t3);
      s2.push(o2);
    }), s2;
  }
  updateServerOffsets(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = new Ui(s2.id, s2.scene, e3, s2.teamId);
      return new Promise((e4, s3) => {
        let i2 = new As({ name: Os.IM_MARK_AS_READ, params: t2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: (t3) => {
          e4(t3);
        }, fail: (e5) => {
          s3(e5);
        } });
        Ds.e(i2);
      });
    });
  }
};
ji.instance = new ji();
var Vi = class {
  constructor() {
    this.offsetMap = /* @__PURE__ */ new Map(), this.markingTime = 0, this.userId = Ds.u();
  }
  updateOffset(e3, t2) {
    let s2 = this.offsetMap.get(e3);
    return es.isDef(s2) ? t2 > s2 && (this.offsetMap.set(e3, t2), true) : (this.offsetMap.set(e3, t2), true);
  }
  updateUserOffsets(e3) {
    e3.forEach((e4) => {
      let t2 = e4.userId, s2 = e4.offset;
      this.updateOffset(t2, s2);
    });
  }
  updateMyOffset(e3) {
    return this.updateOffset(this.userId, e3);
  }
  myOffset() {
    return this.getOffset(this.userId);
  }
  getOffset(e3) {
    let t2 = this.offsetMap.get(e3);
    return t2 || 0;
  }
};
var Hi = class {
  constructor(e3, t2, s2, i2, n2) {
    this.id = e3, this.scene = t2, this.lastTimestamp = s2, this.limit = i2, this.teamId = n2;
  }
};
var Wi = class {
  constructor(e3) {
    this.history = e3;
  }
  pre() {
    this.oldLastMessage = this.history.getMaxMessage(), this.oldUnreadAmount = this.history.unreadAmount(), this.oldLastMessage && (this.oldLastMessageRecalled = this.oldLastMessage.recalled, this.oldLastMessageRead = this.oldLastMessage.read, this.oldLastMessageStatus = this.oldLastMessage.status);
  }
  post() {
    let e3, t2, s2, i2 = this.history.unreadAmount(), n2 = this.history.getMaxMessage();
    n2 && (s2 = n2.status, e3 = n2.read, t2 = n2.recalled);
    let o2 = this.history.target;
    this.oldLastMessage !== n2 || this.oldLastMessageRead !== e3 || this.oldLastMessageRecalled !== t2 || this.oldLastMessageStatus !== s2 ? n2 ? Gs.fire(bi.MAX_MESSAGE_CHANGED, n2) : Gs.fire(bi.MAX_MESSAGE_DELETED, o2) : this.oldUnreadAmount !== i2 && Gs.fire(bi.UNREAD_AMOUNT_CHANGED, o2);
  }
};
var zi = class {
  constructor(e3, t2, s2, i2) {
    this.scene = e3, this.conversationId = t2, this.recaller = s2, this.times = i2;
  }
};
var Xi = class {
  constructor(e3) {
    this.expiredTime = 0, this.remoteHistory = ji.instance, this.target = e3, this.userOffsets = new Vi(), this.messageCache = new Pi(e3);
  }
  initMaxMessageAndOffsets(e3, t2) {
    this.existsMessage(e3) || (this.messageCache.saveMessage(e3), t2.forEach((e4) => {
      this.markLocalMessagesRead(this.messageCache.all(), e4.userId, e4.offset, false);
    }));
  }
  existsMessage(e3) {
    return this.messageCache.existsMessage(e3.messageId);
  }
  loadHistory(e3, s2) {
    return t(this, void 0, void 0, function* () {
      return this.expiredTime > 0 && !this.messageCache.isEmpty() && (yield this.updateByServerChange()), es.isUndef(s2) ? s2 = 10 : s2 > 30 && (s2 = 30), yield this.loadServerMessages(e3, s2);
    });
  }
  loadServerMessages(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = this.messageCache.loadLocalMessages(s2, e3);
      if (false === this.messageCache.allLoaded && t2.length !== s2) {
        let i2 = s2 - t2.length, n2 = t2[0] ? t2[0].timestamp : e3, o2 = new Hi(this.target.id.toString(), this.target.scene, n2, i2, this.target.teamId), r2 = yield this.remoteHistory.loadServerMessages(this.target, o2), a2 = r2.messages;
        t2 = a2.concat(t2), this.messageCache.cacheServerMessages(o2, a2), r2.userOffsets.forEach((e4) => {
          this.userOffsets.updateOffset(e4.userId, e4.offset);
        }), this.userOffsets.offsetMap.forEach((e4, t3) => {
          this.markLocalMessagesRead(a2, t3, e4, false);
        });
      }
      return t2;
    });
  }
  deleteMessages(e3) {
    return t(this, void 0, void 0, function* () {
      yield this.aopUnreadAmountMaxMessage(() => t(this, void 0, void 0, function* () {
        let t2 = e3.messages;
        yield xi.deleteServerMessages(t2), this.messageCache.deleteMessages(t2), xs.onSuccess(e3);
      }));
    });
  }
  syncDeletedMessage(e3, t2) {
    this.aopUnreadAmountMaxMessage(() => {
      this.doSyncDeletedMessage(e3, t2);
    });
  }
  doSyncDeletedMessage(e3, t2) {
    if (e3 === Ds.u()) {
      let e4 = this.messageCache.findMessagesByTimes(t2);
      this.messageCache.deleteMessages(e4), e4.length > 0 && Zn.aec.fire(Qs.MESSAGE_DELETED, e4);
    }
  }
  recallMessages(e3) {
    return t(this, void 0, void 0, function* () {
      yield this.aopUnreadAmountMaxMessage(() => t(this, void 0, void 0, function* () {
        this.doRecall(e3);
      }));
    });
  }
  doRecall(e3) {
    let t2 = this.messageCache.recallMessage(e3);
    t2.length > 0 && Zn.aec.fire(Qs.MESSAGE_RECALLED, t2);
  }
  expire() {
    this.messageCache.isEmpty() || (this.expiredTime = this.messageCache.maxSuccessMessageTime());
  }
  updateByServerChange() {
    return t(this, void 0, void 0, function* () {
      yield this.aopUnreadAmountMaxMessage(() => t(this, void 0, void 0, function* () {
        let e3 = yield this.remoteHistory.sync(this.target.scene, this.target.id, this.expiredTime, this.messageCache.minTime(), this.target.teamId);
        e3.userOffsets.forEach((e4) => {
          this.markLocalMessagesRead(this.messageCache.all(), e4.userId, e4.offset, true);
        });
        let t2 = e3.deletedMessageTimes;
        t2.length > 0 && this.doSyncDeletedMessage(Ds.u(), t2);
        let s2 = e3.recalledMessages;
        s2.length > 0 && s2.forEach((e4) => {
          let t3 = new zi(this.target.scene, this.target.id, e4.recaller, e4.times);
          this.doRecall(t3);
        }), this.expiredTime = 0;
      }));
    });
  }
  markRead() {
    return t(this, void 0, void 0, function* () {
      yield this.aopUnreadAmountMaxMessage(() => t(this, void 0, void 0, function* () {
        let e3 = this.messageCache.maxSuccessMessageTime();
        e3 > this.userOffsets.myOffset() && (this.userOffsets.markingTime = e3, yield this.remoteHistory.updateServerOffsets(e3, this.target), e3 === this.userOffsets.markingTime && this.markLocalMessagesRead(this.messageCache.all(), Ds.u(), e3, true));
      }));
    });
  }
  syncMarkedMessage(e3) {
    this.aopUnreadAmountMaxMessage(() => {
      this.markLocalMessagesRead(this.messageCache.all(), e3.markerId, e3.time, true);
    });
  }
  onMessageSending(e3) {
    this.aopUnreadAmountMaxMessage(() => {
      this.messageCache.saveMessage(e3);
    });
  }
  onMessageSendSuccess(e3) {
    this.aopUnreadAmountMaxMessage(() => {
      this.messageCache.correctPosition(e3), this.markLocalMessagesRead(this.messageCache.all(), Ds.u(), e3.timestamp, true);
    });
  }
  onMessageSendFailed(e3) {
    this.getMaxMessage() === e3 && Gs.fire(bi.MAX_MESSAGE_CHANGED, e3);
  }
  onMessageReceived(e3) {
    this.aopUnreadAmountMaxMessage(() => {
      this.messageCache.saveMessage(e3), this.markLocalMessagesRead(this.messageCache.all(), e3.senderId, e3.timestamp, true);
    });
  }
  aopUnreadAmountMaxMessage(e3, s2) {
    return t(this, void 0, void 0, function* () {
      try {
        let t2 = new Wi(this);
        t2.pre(), yield e3(), t2.post();
      } catch (e4) {
        xs.onFailed(s2, e4);
      }
    });
  }
  markLocalMessagesRead(e3, t2, s2, i2) {
    if (this.userOffsets.updateOffset(t2, s2), this.isOtherUserId(t2)) {
      let t3 = this.markMySentRead(e3, s2);
      i2 && t3.length > 0 && Zn.aec.fire(Qs.MESSAGE_READ, t3);
    } else
      t2 === Ds.u() && this.markOthersSentRead(e3, s2);
  }
  markOthersSentRead(e3, t2) {
    if (this.target.scene === lo.PRIVATE)
      for (let s2 = e3.length - 1; s2 >= 0; s2--) {
        let i2 = e3[s2];
        if (i2.isOtherSent() && i2.timestamp <= t2) {
          if (i2.read)
            break;
          i2.read = true;
        }
      }
  }
  markMySentRead(e3, t2) {
    let s2 = new Array();
    if (this.target.scene === lo.PRIVATE)
      for (let i2 = e3.length - 1; i2 >= 0; i2--) {
        let n2 = e3[i2];
        if (!n2.isOtherSent() && n2.timestamp <= t2 && n2.status === ho.SUCCESS) {
          if (n2.read)
            break;
          n2.read = true, s2.push(n2);
        }
      }
    return s2;
  }
  isOtherUserId(e3) {
    if (this.target.scene === lo.CS) {
      let t2 = this.target.customerId();
      return Ds.u() === t2 ? e3 !== Ds.u() : e3 === t2;
    }
    return e3 !== Ds.u();
  }
  unreadAmount(e3) {
    let t2 = 0, s2 = this.userOffsets.myOffset(), i2 = this.messageCache.all();
    for (const e4 of i2)
      e4.isOtherSent() && false === e4.recalled && e4.timestamp > s2 && (t2 += 1);
    return t2;
  }
  getMaxMessage(e3) {
    return this.messageCache.getMaxMessage();
  }
  maxTime(e3) {
    let t2 = this.getMaxMessage();
    return es.isDef(t2) ? t2.timestamp : 0;
  }
};
var Ji = class {
  constructor(e3, t2) {
    this.teamId = e3, this.customerId = t2;
  }
};
var Yi = class {
};
var Qi = class {
  constructor(e3, t2, s2) {
    this.teamId = e3, this.teamData = JSON.stringify(t2), this.agentData = JSON.stringify(s2);
  }
};
var $i = class {
  constructor(e3) {
    this.teamId = e3;
  }
};
var Ki = class {
  constructor(e3) {
    this.teamId = e3;
  }
};
var Zi = class _Zi {
  static getInstance() {
    return _Zi.instance || (_Zi.instance = new _Zi()), _Zi.instance;
  }
  constructor() {
    this.synchronized = true, Ds.s().addDisconnectedObserver(this.onDisconnected.bind(this)), Ds.s().addConnectedObserver(this.onConnected.bind(this)), Ds.s().addMessageObserver(Ys.CS_ONLINE_CHANGED, this.onlineChanged.bind(this));
  }
  queryTeams() {
    return this.queryMyTeamPromise || (this.queryMyTeamPromise = new Promise((e3, t2) => {
      let s2 = new As({ name: Os.CS_MY_TEAMS, params: {}, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e4) => {
        t2(e4);
      }, success: (t3) => {
        this.teamIds = new Set(t3.content), this.synchronized = true, e3(this.teamIds);
      } });
      Ds.e(s2);
    })), this.queryMyTeamPromise;
  }
  myTeams() {
    if (this.synchronized && this.queryMyTeamPromise)
      return this.teamIds;
    throw "please query team first.";
  }
  isOnline(e3, s2) {
    return t(this, void 0, void 0, function* () {
      yield this.queryTeams(), xs.onSuccess(s2, this.teamIds.has(e3));
    });
  }
  online(e3, t2) {
    if (!es.isObject(t2.agentData) || !es.isObject(t2.teamData))
      throw { code: 400, content: "agentData and teamData require an object" };
    let s2 = new Qi(e3, t2.teamData, t2.agentData), i2 = new As({ name: Os.CS_ONLINE, params: s2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e4) => {
      xs.onFailed(t2, e4);
    }, success: (s3) => {
      this.teamIds.add(e3), xs.onSuccess(t2), Gs.fire(bi.CS_ONLINE_SUCCESS);
    } });
    Ds.e(i2);
  }
  offline(e3, t2) {
    let s2 = new $i(e3), i2 = new As({ name: Os.CS_OFFLINE, params: s2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e4) => {
      xs.onFailed(t2, e4);
    }, success: (s3) => {
      this.teamIds.delete(e3), xs.onSuccess(t2), Gs.fire(bi.CS_OFFLINE_SUCCESS);
    } });
    Ds.e(i2);
  }
  agents(e3, t2) {
    let s2 = new Ki(e3), i2 = new As({ name: Os.CS_AGENTS, params: s2, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e4) => {
      xs.onFailed(t2, e4);
    }, success: (e4) => {
      e4.content.forEach((e5) => {
        e5.data = JSON.parse(e5.data);
      }), xs.onSuccess(t2, e4);
    } });
    Ds.e(i2);
  }
  onlineChanged(e3) {
    e3.online ? this.teamIds.add(e3.teamId) : this.teamIds.delete(e3.teamId);
  }
  onDisconnected() {
    this.queryMyTeamPromise = null, this.teamIds = null;
  }
  onConnected() {
    this.synchronized && (this.queryMyTeamPromise = this.queryTeams());
  }
};
var en = class _en {
  constructor(e3) {
    this.teamId = e3, Gs.on(bi.CS_AGENT_MESSAGE_RECEIVED, this.onMessageReceived), Gs.on(bi.CS_ACCEPTED, this.onMessageReceived), Gs.on(bi.CS_ENDED, this.onMessageReceived), Gs.on(bi.CS_TRANSFER, this.onMessageReceived), Gs.on(Bs.MANUAL_DISCONNECTED, _en.destroy);
  }
  static live(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = s2.customerId;
      Ws.validateId(t2, "customerId");
      let i2 = new Ji(e3, t2);
      yield Zi.getInstance().queryTeams();
      let n2 = new As({ name: Os.CS_LIVE_SESSION, params: i2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e4) => {
        xs.onFailed(s2, e4);
      }, success: (t3) => {
        _en.destroy(), this.session = new _en(e3), this.session.liveOptions = s2;
        let i3 = t3.content.customerStatus;
        "ACCEPTED" === i3.status && (i3.agent.data = JSON.parse(i3.agent.data)), this.session.status = i3, this.session.liveOptions.onStatusUpdated(this.session.status), xs.onSuccess(s2);
      } });
      Ds.e(n2);
    });
  }
  customerId() {
    return this.liveOptions.customerId;
  }
  static isMyCustomer(e3) {
    let t2 = _en.session;
    if (t2 && t2.teamId === e3.teamId && t2.customerId() === e3.customerId()) {
      let s2 = Zi.getInstance().myTeams(), i2 = t2.status.agent;
      return s2.has(e3.teamId) && (!i2 || i2.id === Ds.u());
    }
    return true;
  }
  static isMyMessage(e3) {
    let t2 = ki.byIMMessage(e3);
    return e3.type === wi.TRANSFER && e3.payload.transferTo.id === Ds.u() || this.isMyCustomer(t2);
  }
  static quit(e3) {
    let t2 = _en.session;
    if (t2) {
      let s2 = t2.liveOptions.customerId;
      Ws.validateId(s2, "customerId");
      let i2 = new Ji(t2.teamId, s2), n2 = new As({ name: Os.CS_QUIT_LIVE, params: i2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (t3) => {
        xs.onFailed(e3, t3);
      }, success: (t3) => {
        _en.destroy(), xs.onSuccess(e3);
      } });
      Ds.e(n2);
    }
  }
  static destroy() {
    let e3 = _en.session;
    e3 && (Gs.off(bi.CS_AGENT_MESSAGE_RECEIVED, e3.onMessageReceived), Gs.off(bi.CS_ACCEPTED, e3.onMessageReceived), Gs.off(bi.CS_ENDED, e3.onMessageReceived), Gs.off(bi.CS_TRANSFER, e3.onMessageReceived), Gs.off(Bs.MANUAL_DISCONNECTED, _en.destroy), _en.session = null);
  }
  onMessageReceived(e3) {
    let t2 = _en.session;
    if (e3.scene() === lo.CS && t2.liveOptions) {
      let s2 = e3, i2 = t2.liveOptions.customerId;
      t2.teamId === s2.teamId && s2.customerId() === i2 && (t2.tryUpdateStatus(s2), t2.liveOptions.onNewMessage(s2));
    }
  }
  tryUpdateStatus(e3) {
    if ("FREE" !== this.status.status && this.status.sessionId > e3.sessionId)
      return;
    let t2;
    switch (e3.type) {
      case wi.ACCEPT:
        t2 = new Yi(), t2.status = "ACCEPTED", t2.start = e3.payload.sessionStart, t2.sessionId = e3.sessionId, t2.agent = new fo(e3.senderId, e3.senderData);
        break;
      case wi.END:
        t2 = new Yi(), t2.status = "FREE";
        break;
      case wi.TRANSFER:
        t2 = new Yi(), t2.status = "ACCEPTED", t2.start = e3.payload.sessionStart, t2.sessionId = e3.sessionId, t2.agent = e3.payload.transferTo;
        break;
      default:
        "FREE" === this.status.status && (t2 = new Yi(), t2.status = "PENDING", t2.start = e3.timestamp, t2.sessionId = e3.sessionId);
    }
    t2 && (this.status = t2, this.liveOptions.onStatusUpdated(t2));
  }
};
var tn = class extends Xi {
  constructor(e3) {
    super(e3), this.unread = 0, this.markingAmount = 0;
  }
  loadHistory(e3, s2) {
    return t(this, void 0, void 0, function* () {
      return es.isUndef(s2) ? s2 = 10 : s2 > 30 && (s2 = 30), yield this.loadServerMessages(e3, s2);
    });
  }
  loadServerMessages(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = new Hi(this.target.id.toString(), this.target.scene, e3, s2, this.target.teamId), i2 = yield this.remoteHistory.loadServerMessages(this.target, t2);
      return i2.userOffsets.forEach((e4) => {
        this.userOffsets.updateOffset(e4.userId, e4.offset);
      }), i2.messages;
    });
  }
  deleteMessages(e3) {
    return t(this, void 0, void 0, function* () {
      xs.onFailed(e3, "Delete CS message is not supported yet");
    });
  }
  initMaxMessageAndOffsets(e3, t2) {
    t2.forEach((e4) => {
      this.userOffsets.updateOffset(e4.userId, e4.offset);
    }), (es.isUndef(this.acceptedMaxMessage) || this.acceptedMaxMessage.timestamp < e3.timestamp) && this.increaseUnreadAmount(e3), this.saveAcceptedMessage(e3);
  }
  initPendingMaxMessageAndOffsets(e3, t2) {
    t2.forEach((e4) => {
      this.userOffsets.updateOffset(e4.userId, e4.offset);
    }), this.savePendingMessage(e3);
  }
  savePendingMessage(e3) {
    this.pendingMaxMessage ? this.pendingMaxMessage.timestamp < e3.timestamp && (this.pendingMaxMessage = e3) : this.pendingMaxMessage = e3;
  }
  saveAcceptedMessage(e3) {
    this.acceptedMaxMessage ? this.acceptedMaxMessage.timestamp < e3.timestamp && (this.acceptedMaxMessage = e3) : this.acceptedMaxMessage = e3;
  }
  onMessageSending(e3) {
    this.saveAcceptedMessage(e3), Gs.fire(bi.MAX_MESSAGE_CHANGED, e3);
  }
  onMessageSendSuccess(e3) {
    this.saveAcceptedMessage(e3), this.userOffsets.updateOffset(e3.senderId, e3.timestamp), this.acceptedMaxMessage === e3 && Gs.fire(bi.MAX_MESSAGE_CHANGED, e3);
  }
  onMessageSendFailed(e3) {
    this.acceptedMaxMessage === e3 && Gs.fire(bi.MAX_MESSAGE_CHANGED, e3);
  }
  onMessageReceived(e3) {
    en.isMyMessage(e3) && (!e3.accepted || e3.senderId !== Ds.u() && e3.type === wi.ACCEPT ? this.savePendingMessage(e3) : this.saveAcceptedMessage(e3), this.userOffsets.updateOffset(e3.senderId, e3.timestamp), this.increaseUnreadAmount(e3), Gs.fire(bi.MAX_MESSAGE_CHANGED, e3));
  }
  increaseUnreadAmount(e3) {
    if (e3.sendByCustomer() || e3.type === wi.TRANSFER && e3.senderId !== Ds.u()) {
      this.userOffsets.myOffset() < e3.timestamp && e3.accepted && (this.unread += 1);
    }
  }
  markRead() {
    return t(this, void 0, void 0, function* () {
      let e3 = this.maxAcceptedMessageTime();
      en.isMyCustomer(this.target) && this.preMark(e3) && (yield this.remoteHistory.updateServerOffsets(e3, this.target), this.postMark(e3));
    });
  }
  preMark(e3) {
    let t2 = this.userOffsets.myOffset();
    return e3 > this.userOffsets.markingTime && e3 > t2 && (this.userOffsets.markingTime = e3, this.markingAmount = this.unread, true);
  }
  postMark(e3) {
    e3 === this.userOffsets.markingTime && (this.unread -= this.markingAmount, this.markingAmount = 0, this.userOffsets.updateOffset(Ds.u(), e3), Gs.fire(bi.UNREAD_AMOUNT_CHANGED, this.target));
  }
  syncMarkedMessage(e3) {
  }
  getMaxMessage(e3) {
    return e3 ? this.acceptedMaxMessage : this.pendingMaxMessage;
  }
  unreadAmount(e3) {
    return e3 ? this.unread : 0;
  }
  existsMessage(e3) {
    return this.acceptedMaxMessage && this.acceptedMaxMessage.messageId === e3.messageId || this.pendingMaxMessage && this.pendingMaxMessage.messageId === e3.messageId;
  }
  maxAcceptedMessageTime() {
    return this.acceptedMaxMessage ? this.acceptedMaxMessage.timestamp : 0;
  }
  maxTime(e3) {
    let t2 = this.getMaxMessage(e3);
    return t2 ? t2.timestamp : 0;
  }
};
var sn = class extends Xi {
  constructor(e3) {
    super(e3);
  }
  deleteMessages(e3) {
    return t(this, void 0, void 0, function* () {
      xs.onFailed(e3, "Delete CS message is not supported yet");
    });
  }
};
var nn = class {
  static validateMessageArray(e3) {
    if (!es.isArray(e3) || es.isEmpty(e3))
      throw { code: 400, content: "messages requires non empty array" };
    if (e3.length > 20)
      throw { code: 400, content: "The maximum number of messages is 20" };
    let t2 = ki.byIMMessage(e3[0]);
    for (let s2 = 0; s2 < e3.length; s2++) {
      let i2 = e3[s2];
      if (!(i2 instanceof Ri))
        throw { code: 400, content: "message[" + s2 + "] is not a correct message" };
      if (s2 > 0) {
        let e4 = ki.byIMMessage(i2);
        if (e4.scene !== t2.scene || e4.id !== t2.id)
          throw { code: 400, content: "each message must be from the same friend or group" };
      }
    }
  }
};
var on = class _on {
  static init() {
    return _on.instance || (_on.instance = new _on()), _on.instance.map = /* @__PURE__ */ new Map(), _on.instance;
  }
  initialListeners() {
    Gs.on(bi.MESSAGE_SENDING, (e3) => this.onMessageSending(e3)), Gs.on(bi.MESSAGE_SEND_SUCCESS, (e3) => this.onMessageSendSuccess(e3)), Gs.on(bi.MESSAGE_SEND_FAILED, (e3) => this.onMessageSendFailed(e3)), Gs.on(bi.MESSAGE_RECEIVED, (e3) => this.onMessageReceived(e3)), Gs.on(bi.CS_AGENT_MESSAGE_RECEIVED, (e3) => this.onMessageReceived(e3)), Gs.on(bi.CS_ACCEPTED, (e3) => this.onMessageReceived(e3)), Gs.on(bi.CS_ENDED, (e3) => this.onMessageReceived(e3)), Gs.on(bi.CS_TRANSFER, (e3) => this.onMessageReceived(e3)), Gs.on(bi.MESSAGE_RECALLED, (e3) => this.onMessageRecalled(e3)), Ds.s().addMessageObserver(Ys.IM_MSG_READ, this.onRemoteMarkRead.bind(this)), Ds.s().addMessageObserver(Ys.IM_MSG_DELETED, this.onRemoteMessageDeleted.bind(this)), Ds.s().addDisconnectedObserver(this.onDisconnected.bind(this));
  }
  loadHistory(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = this.queryToTarget(e3, s2), i2 = this.findOrCreateHistory(t2), n2 = yield i2.loadHistory(e3.lastTimestamp, e3.limit);
      xs.onSuccess(e3, { code: 200, content: n2 });
    });
  }
  queryToTarget(e3, t2) {
    if (es.isDef(e3.userId))
      return new ki(lo.PRIVATE, e3.userId);
    if (es.isDef(e3.groupId))
      return new ki(lo.GROUP, e3.groupId);
    if (es.isDef(e3.type)) {
      if (!Object.values(lo).includes(e3.type))
        throw new Error("incorrect type, must be: " + Object.values(lo));
      if (es.isUndef(e3.id))
        throw new Error("If type is not empty, id is required.");
      return lo.CS == e3.type && es.isUndef(t2) && (t2 = e3.id), new ki(e3.type, e3.id, t2);
    }
    throw new Error("incorrect query options.");
  }
  onMessageSending(e3) {
    let t2 = ki.byIMMessage(e3);
    this.findOrCreateHistory(t2).onMessageSending(e3);
  }
  onMessageSendSuccess(e3) {
    let t2 = ki.byIMMessage(e3);
    this.findHistory(t2).onMessageSendSuccess(e3);
  }
  onMessageSendFailed(e3) {
    let t2 = ki.byIMMessage(e3);
    this.findHistory(t2).onMessageSendFailed(e3);
  }
  onMessageReceived(e3) {
    let t2 = ki.byIMMessage(e3);
    this.findOrCreateHistory(t2).onMessageReceived(e3);
  }
  privateMarkAsRead(e3) {
    return t(this, void 0, void 0, function* () {
      if (es.isUndef(e3.userId))
        throw new Error("userId could not be empty.");
      let t2 = ki.byScene(lo.PRIVATE, e3.userId);
      yield this.markAsRead(t2, e3);
    });
  }
  groupMarkAsRead(e3) {
    return t(this, void 0, void 0, function* () {
      if (es.isUndef(e3.groupId))
        throw new Error("groupId could not be empty.");
      let t2 = ki.byScene(lo.GROUP, e3.groupId);
      yield this.markAsRead(t2, e3);
    });
  }
  markMessageAsRead(e3, s2) {
    return t(this, void 0, void 0, function* () {
      if (es.isUndef(e3.id))
        throw new Error("id could not be empty.");
      if (!Object.values(lo).includes(e3.type))
        throw new Error("incorrect type, must be: " + Object.values(lo));
      lo.CS == e3.type && es.isUndef(s2) && (s2 = e3.id);
      let t2 = ki.byScene(e3.type, e3.id, s2);
      yield this.markAsRead(t2, e3);
    });
  }
  markAsRead(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = this.findHistory(e3);
      t2 && (yield t2.markRead()), xs.onSuccess(s2);
    });
  }
  onRemoteMarkRead(e3) {
    let t2 = ki.byMessageReadRemoteEvent(e3), s2 = this.findHistory(t2);
    s2 && s2.syncMarkedMessage(e3);
  }
  deleteMessage(e3) {
    return t(this, void 0, void 0, function* () {
      this.validateMessageArray(e3.messages), xi.validate(e3);
      let t2 = e3.messages[0], s2 = ki.byIMMessage(t2), i2 = this.findHistory(s2);
      if (!i2)
        throw { code: 400, content: "No message that could be deleted" };
      yield i2.deleteMessages(e3);
    });
  }
  onRemoteMessageDeleted(e3) {
    let t2 = ki.byIMMessageDeletedEvent(e3), s2 = this.findHistory(t2);
    s2 && s2.syncDeletedMessage(e3.deleterId, e3.times);
  }
  onMessageRecalled(e3) {
    let t2 = ki.byConversationId(e3.scene, e3.conversationId), s2 = this.findHistory(t2);
    s2 && s2.recallMessages(e3);
  }
  onDisconnected() {
    this.map.forEach((e3, t2) => {
      e3.expire();
    });
  }
  findOrCreateHistory(e3) {
    let t2 = this.findHistory(e3);
    return t2 || (t2 = e3.scene === lo.CS ? Ds.u() === e3.customerId() ? new sn(e3) : new tn(e3) : new Xi(e3), this.map.set(e3.toString(), t2), t2);
  }
  static get(e3) {
    return _on.instance.findOrCreateHistory(e3);
  }
  findHistory(e3) {
    return this.map.get(e3.toString());
  }
  validateMessageArray(e3) {
    nn.validateMessageArray(e3);
  }
};
var rn = class {
  constructor(e3) {
    this.top = false, this.data = null, this.dataLoaded = false, this.target = e3;
  }
  toDto() {
    let e3 = this.target.scene, t2 = this.target.id, s2 = new po();
    return e3 === lo.PRIVATE ? s2.userId = t2 : e3 === lo.GROUP ? s2.groupId = t2 : e3 === lo.CS && (s2.id = this.target.teamId), s2.type = e3, s2.lastMessage = this.getMaxMessage(), s2.unread = this.getUnreadAmount(), s2.top = this.top, s2.data = this.data, s2;
  }
  getMaxMessage() {
    return on.get(this.target).getMaxMessage();
  }
  getUnreadAmount() {
    return on.get(this.target).unreadAmount();
  }
  maxMessageTime() {
    return on.get(this.target).maxTime();
  }
};
var an = class extends rn {
  constructor(e3) {
    super(e3), this.accepted = false;
  }
  toDto() {
    let e3 = new po(), t2 = this.target.scene, s2 = this.target.id, i2 = this.target.teamId;
    return e3.id = s2, e3.teamId = i2, e3.type = t2, e3.lastMessage = this.getMaxMessage(), e3.unread = this.getUnreadAmount(), e3.top = this.top, e3.data = this.data, e3.ended = this.isEnded(), e3;
  }
  isEnded() {
    let e3 = this.getMaxMessage(), t2 = e3.type, s2 = e3.payload;
    return t2 === wi.END || t2 === wi.TRANSFER && s2.transferTo.id !== Ds.u();
  }
  getMaxMessage() {
    return on.get(this.target).getMaxMessage(this.accepted);
  }
  getUnreadAmount() {
    return on.get(this.target).unreadAmount(this.accepted);
  }
  maxMessageTime() {
    return on.get(this.target).maxTime(this.accepted);
  }
};
var cn = class {
  constructor(e3, t2, s2, i2) {
    this.type = e3, this.top = t2, this.targetId = s2, this.teamId = i2;
  }
};
var un = class {
  constructor(e3, t2, s2) {
    this.type = e3, this.targetId = t2, this.teamId = s2;
  }
};
var ln = class {
  constructor(e3, t2, s2) {
    this.type = e3, this.targetId = t2, this.teamId = s2;
  }
};
var dn = class {
  top(e3, t2) {
    let s2 = new cn(e3.scene, t2, e3.id, e3.teamId);
    return new Promise((e4, t3) => {
      let i2 = new As({ name: Os.topConversation, params: s2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: (s3) => {
        200 === s3.code ? e4(s3) : t3(s3);
      }, fail: (e5) => {
        t3(e5);
      } });
      Ds.e(i2);
    });
  }
  remove(e3) {
    let t2 = new un(e3.scene, e3.id, e3.teamId);
    return new Promise((e4, s2) => {
      let i2 = new As({ name: Os.removeConversation, params: t2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: (t3) => {
        200 == t3.code ? e4(t3) : s2(t3);
      }, fail: (e5) => {
        s2(e5);
      } });
      Ds.e(i2);
    });
  }
  query(e3) {
    return new Promise((s2, i2) => {
      let n2 = new As({ name: e3, params: {}, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e4) => {
        i2(e4);
      }, success: (e4) => t(this, void 0, void 0, function* () {
        s2(e4);
      }) });
      Ds.e(n2);
    });
  }
  loadData(e3) {
    let t2 = new ln(e3.scene, e3.id, e3.teamId);
    return new Promise((e4, s2) => {
      let i2 = new As({ name: Os.imData, params: t2, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, success: (t3) => {
        let s3 = JSON.parse(t3.content);
        e4(s3);
      }, fail: (e5) => {
        s2(e5);
      } });
      Ds.e(i2);
    });
  }
};
dn.instance = new dn();
var hn = class _hn {
  constructor() {
    this.list = new Array(), this.builder = new qi(), this.remoteConversations = dn.instance, this.synchronized = false, Gs.on(bi.MAX_MESSAGE_CHANGED, (e3) => this.onMaxMessageChanged(e3)), Gs.on(bi.UNREAD_AMOUNT_CHANGED, (e3) => this.onUnreadMessageChanged(e3)), Gs.on(bi.MAX_MESSAGE_DELETED, (e3) => this.onMaxMessageDeleted(e3));
  }
  onUnreadMessageChanged(e3) {
    this.findConversation(e3) && this.fireUpdated();
  }
  fireUpdated() {
    let e3 = this.loadLocalConversations(), t2 = this.getUpdatedEventName();
    Zn.aec.fire(t2, { unreadTotal: e3.content.unreadTotal, conversations: e3.content.conversations });
  }
  getUpdatedEventName() {
    return Qs.CONVERSATIONS_UPDATED;
  }
  latestConversations(e3) {
    return t(this, void 0, void 0, function* () {
      this.synchronized || (yield this.loadServerConversations());
      let t2 = this.loadLocalConversations();
      xs.onSuccess(e3, t2);
    });
  }
  loadServerConversations() {
    return t(this, void 0, void 0, function* () {
      let e3 = this.rocketName(), t2 = yield this.remoteConversations.query(e3);
      this.convertAbbrConversation(t2.content), this.synchronized = true;
    });
  }
  rocketName() {
    return Os.imLastConversations;
  }
  convertAbbrConversation(e3) {
    let t2 = e3;
    for (const e4 of t2) {
      let t3 = e4.t, s2 = e4.top, i2 = e4.d ? JSON.parse(e4.d) : {}, n2 = e4.userOffsets;
      e4.lmsg.t = t3;
      let o2 = e4.lmsg, r2 = this.builder.build(o2), a2 = ki.byIMMessage(r2), c2 = this.findConversation(a2);
      es.isUndef(c2) ? (c2 = this.buildByAbbr(e4, r2), this.insertOne(c2)) : (c2.top = s2, c2.data = i2), on.get(a2).initMaxMessageAndOffsets(r2, n2), this.correctPosition(c2);
    }
  }
  onMaxMessageDeleted(e3) {
    this.removeConversation(e3);
  }
  onMaxMessageChanged(e3) {
    return t(this, void 0, void 0, function* () {
      if (e3.scene() === lo.CS) {
        let t2 = e3;
        if (Ds.u() != t2.customerId() && (false === t2.accepted || t2.type === wi.ACCEPT && t2.senderId != Ds.u()))
          return;
      }
      yield this.saveOrUpdateConversation(e3);
    });
  }
  saveOrUpdateConversation(e3) {
    return t(this, void 0, void 0, function* () {
      let t2 = e3.status, s2 = ki.byIMMessage(e3), i2 = this.findConversation(s2);
      es.isUndef(i2) && t2 !== ho.FAIL && (i2 = this.buildByMessage(e3), this.insertOne(i2), t2 === ho.SUCCESS && (i2.data = yield this.remoteConversations.loadData(s2), i2.dataLoaded = true)), t2 === ho.SENDING && (i2.data = e3.getToData(), i2.dataLoaded = true), i2 && i2.dataLoaded && (this.correctPosition(i2), this.fireUpdated());
    });
  }
  loadLocalConversations() {
    let e3 = 0, t2 = new Array();
    for (const s2 of this.list)
      if (s2.dataLoaded && s2.getMaxMessage()) {
        e3 += s2.getUnreadAmount();
        let i2 = s2.toDto();
        t2.push(i2);
      }
    return { code: 200, content: { unreadTotal: e3, conversations: t2 } };
  }
  findConversationIndex(e3) {
    return this.list.findIndex((t2) => e3.toString() === t2.target.toString());
  }
  findConversation(e3) {
    let t2 = this.findConversationIndex(e3);
    return this.list[t2];
  }
  removeLocalConversation(e3) {
    let t2 = this.findConversationIndex(e3.target);
    this.list.splice(t2, 1);
  }
  insertOne(e3) {
    _hn.sortedInserter.insert(this.list, e3), this.list.length > _hn.CONVERSATIONS_MAX_LENGTH && (this.list = this.list.slice(0, _hn.CONVERSATIONS_MAX_LENGTH));
  }
  correctPosition(e3) {
    this.removeLocalConversation(e3), this.insertOne(e3);
  }
  removeConversation(e3) {
    let t2 = this.findConversation(e3);
    t2 && (this.removeLocalConversation(t2), this.fireUpdated());
  }
  top(e3, s2, i2) {
    return t(this, void 0, void 0, function* () {
      if (!es.isBoolean(s2))
        throw new Error("top must be boolean.");
      let t2 = this.findConversation(e3);
      if (!t2)
        throw new Error("conversation does not exist.");
      t2.top != s2 && (yield this.remoteConversations.top(e3, s2), t2.top = s2, this.correctPosition(t2)), this.fireUpdated(), xs.onSuccess(i2);
    });
  }
  remove(e3, s2) {
    return t(this, void 0, void 0, function* () {
      let t2 = this.findConversation(e3);
      if (!t2)
        throw new Error("conversation does not exist.");
      if (t2 instanceof an && !t2.isEnded())
        throw new Error("CS conversation can only be deleted after it ends");
      yield this.remoteConversations.remove(e3), this.removeLocalConversation(t2), this.fireUpdated(), xs.onSuccess(s2);
    });
  }
  buildByAbbr(e3, t2) {
    let s2, i2 = ki.byIMMessage(t2);
    if (e3.t === lo.CS) {
      let e4 = t2;
      Ds.u() === e4.customerId() ? s2 = new rn(i2) : (s2 = new an(i2), s2.accepted = e4.accepted);
    } else
      s2 = new rn(i2);
    return s2.dataLoaded = true, s2.top = e3.top, s2.data = e3.d ? JSON.parse(e3.d) : {}, s2;
  }
  buildByMessage(e3) {
    let t2, s2 = ki.byIMMessage(e3);
    if (e3.scene() === lo.CS) {
      let i2 = e3;
      Ds.u() === i2.customerId() ? t2 = new rn(s2) : (t2 = new an(s2), t2.accepted = i2.accepted);
    } else
      t2 = new rn(s2);
    return t2;
  }
};
hn.CONVERSATIONS_MAX_LENGTH = 200, hn.sortedInserter = new class extends _i {
  compare(e3, t2) {
    let s2;
    if (e3.top == t2.top) {
      let i2 = e3.maxMessageTime();
      s2 = t2.maxMessageTime() - i2;
    } else
      s2 = e3.top ? -1 : 1;
    return 0 === s2 ? 0 : s2 > 0 ? 1 : -1;
  }
}();
var pn = class extends hn {
  constructor() {
    super(), this.expired = false, Gs.on(bi.CS_ONLINE_SUCCESS, () => this.onCSOnlineSuccess()), Gs.on(bi.CS_OFFLINE_SUCCESS, () => this.onCSOfflineSuccess()), Ds.s().addDisconnectedObserver(this.onDisconnected.bind(this)), Ds.s().addConnectedObserver(this.onConnected.bind(this));
  }
  onMaxMessageChanged(e3) {
    return t(this, void 0, void 0, function* () {
      if (e3.scene() === lo.CS) {
        let t2 = e3;
        if (t2.customerId() != Ds.u() && (false === t2.accepted || t2.type === wi.ACCEPT))
          if (wi.ACCEPT === e3.type) {
            let t3 = ki.byIMMessage(e3);
            this.removeConversation(t3);
          } else
            yield this.saveOrUpdateConversation(e3);
      }
    });
  }
  latestConversations(e3) {
    const s2 = Object.create(null, { latestConversations: { get: () => super.latestConversations } });
    return t(this, void 0, void 0, function* () {
      let t2 = this.synchronized;
      yield s2.latestConversations.call(this, e3), this.list.length > 0 && !t2 && this.fireUpdated();
    });
  }
  onUnreadMessageChanged(e3) {
  }
  onCSOnlineSuccess() {
    return t(this, void 0, void 0, function* () {
      yield this.loadServerConversations(), this.fireUpdated();
    });
  }
  onCSOfflineSuccess() {
    this.list = [], this.fireUpdated();
  }
  getUpdatedEventName() {
    return Qs.PENDING_CONVERSATIONS_UPDATED;
  }
  rocketName() {
    return Os.CS_PENDING_CONVERSATION;
  }
  convertAbbrConversation(e3) {
    return t(this, void 0, void 0, function* () {
      let t2 = e3;
      for (const e4 of t2) {
        e4.lastMessage.t = lo.CS;
        let t3 = e4.customerData, s2 = e4.lastMessage, i2 = e4.userOffsets, n2 = t3 ? JSON.parse(t3) : {}, o2 = this.builder.build(s2), r2 = ki.byIMMessage(o2), a2 = this.findConversation(r2);
        es.isUndef(a2) && (a2 = new an(r2), a2.accepted = o2.accepted, a2.dataLoaded = true, this.insertOne(a2)), a2.top = false, a2.data = n2, on.get(r2).initPendingMaxMessageAndOffsets(o2, i2), this.correctPosition(a2);
      }
    });
  }
  onDisconnected() {
    this.expired = true;
  }
  onConnected() {
    return t(this, void 0, void 0, function* () {
      let e3 = Ds.supportIM();
      this.expired && e3 && (this.expired = false, this.list = [], yield this.loadServerConversations(), this.fireUpdated());
    });
  }
};
var mn = class {
  constructor() {
    this.conversations = new hn(), this.pendingConversations = new pn();
  }
  latestConversations(e3) {
    this.conversations.latestConversations(e3);
  }
  latestPendingConversations(e3) {
    this.pendingConversations.latestConversations(e3);
  }
  topPrivateConversation(e3) {
    let t2 = ki.byScene(lo.PRIVATE, e3.userId);
    this.conversations.top(t2, e3.top, e3);
  }
  topGroupConversation(e3) {
    let t2 = ki.byScene(lo.GROUP, e3.groupId);
    this.conversations.top(t2, e3.top, e3);
  }
  topConversation(e3) {
    let t2 = e3.conversation;
    this.validateConversationDTO(t2);
    let s2 = ki.byConversationDTO(t2);
    this.conversations.top(s2, e3.top, e3);
  }
  removePrivateConversation(e3) {
    let t2 = ki.byScene(lo.PRIVATE, e3.userId);
    this.conversations.remove(t2, e3);
  }
  removeGroupConversation(e3) {
    let t2 = ki.byScene(lo.GROUP, e3.groupId);
    this.conversations.remove(t2, e3);
  }
  removeConversation(e3) {
    let t2 = e3.conversation;
    this.validateConversationDTO(t2);
    let s2 = ki.byConversationDTO(t2);
    this.conversations.remove(s2, e3);
  }
  validateConversationDTO(e3) {
    if (!(e3 instanceof po))
      throw new Error("Incorrect conversation object.");
    {
      let t2 = e3.lastMessage;
      if (t2 instanceof Bi && t2.customerId() !== Ds.u() && false === t2.accepted)
        throw new Error("pending conversation cannot be topped or removed.");
    }
  }
};
var fn = class {
  constructor() {
    this.builder = new qi(), Fs.instance.addAssembler(new class {
      assemble(e3) {
        let t2 = { messageId: e3.id, timestamp: e3.tm, type: e3.t, senderId: e3.sid, toType: e3.tt };
        return e3.tt === lo.GROUP && (t2.groupId = e3.gid), t2;
      }
      support(e3) {
        return !!e3.sid;
      }
    }());
  }
  initialGoEasySocket() {
    Ds.s().addMessageObserver(Ys.imMessage, this.onMessageReceived.bind(this));
  }
  onMessageReceived(e3) {
    if (e3.t !== lo.CS) {
      let t2 = this.builder.build(e3);
      this.sendAck(t2);
      let s2 = ki.byIMMessage(t2), i2 = s2.scene;
      on.get(s2).existsMessage(t2) || (this.createNotification(e3), Gs.fire(bi.MESSAGE_RECEIVED, t2), i2 === lo.PRIVATE ? Zn.aec.fire(Qs.PRIVATE_MESSAGE_RECEIVED, t2) : i2 === lo.GROUP && Zn.aec.fire(Qs.GROUP_MESSAGE_RECEIVED, t2));
    }
  }
  sendAck(e3) {
    Ds.s().sendAck("imAck", { publishGuid: e3.messageId });
  }
  createNotification(e3) {
    const t2 = Fs.instance.supportNotification();
    if (!es.isObject(e3.nt) || e3.s === Ds.u() || !t2)
      return;
    let s2 = { id: e3.i, tm: e3.ts, t: e3.mt, sid: e3.s, tt: e3.t };
    s2.tt === lo.GROUP && (s2.gid = e3.r), Fs.instance.createLocalNotification(e3.nt.t, e3.nt.c, s2, e3.nt.sound, e3.nt.badge);
  }
};
var gn = class {
  subscribe(e3) {
    Ws.validateIdArray(e3.groupIds, "groupIds"), e3.groupIds = e3.groupIds.toString().split(",");
    let t2 = new As({ name: Os.subscribeGroups, params: { groupIds: e3.groupIds, at: e3.accessToken }, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: function() {
      xs.onSuccess(e3, { code: 200, content: "ok" });
    }, fail: function(t3) {
      xs.onFailed(e3, { code: t3.resultCode || 408, content: t3.content || "Failed to subscribe group message" });
    } });
    Ds.e(t2);
  }
  unsubscribe(e3) {
    Ws.validateId(e3.groupId, "groupId"), e3.groupId = e3.groupId.toString();
    let t2 = new As({ name: Os.unsubscribeGroup, params: { groupId: e3.groupId }, permission: Jt.READ, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, success: () => {
      xs.onSuccess(e3, { code: 200, content: "ok" });
    }, fail: (t3) => {
      xs.onFailed(e3, { code: t3.resultCode || 408, content: t3.content || "Failed to unsubscribe group message" });
    } });
    Ds.e(t2);
  }
};
var yn = class {
  constructor() {
    Ds.s().addMessageObserver(Ys.groupPresence, this.newMessageReceived.bind(this));
  }
  presence(e3) {
    Ws.validateIdArray(e3.groupIds, "groupIds"), e3.groupIds.toString().split(",");
    let t2 = { groupIds: e3.groupIds };
    this.emitRocket(Os.subscribeGroupPresence, t2, () => {
      xs.onSuccess(e3, { code: 200, content: "ok" });
    }, (t3) => {
      xs.onFailed(e3, { code: t3.code || 408, content: t3.content || "Failed to subscribe group message" });
    }, Rs.commonRequestSingle, Rs.commonRequestTotal);
  }
  unPresence(e3) {
    Ws.validateId(e3.groupId, "groupId"), e3.groupId = e3.groupId.toString();
    let t2 = { groupId: e3.groupId };
    this.emitRocket(Os.unsubscribeGroupPresence, t2, () => {
      xs.onSuccess(e3, { code: 200, content: "ok" });
    }, (t3) => {
      xs.onFailed(e3, { code: t3.code || 408, content: t3.content || "Failed to unsubscribe presence" });
    }, Rs.commonRequestSingle, Rs.commonRequestTotal);
  }
  emitRocket(e3, t2, s2, i2, n2, o2) {
    let r2 = new As({ name: e3, params: t2, singleTimeout: n2, totalTimeout: o2, permission: Jt.WRITE, success: s2, fail: i2 });
    Ds.e(r2);
  }
  newMessageReceived(e3) {
    let t2 = null;
    e3.c && (t2 = JSON.parse(e3.c)), t2 && t2.events && t2.events.map((e4) => {
      let s2 = e4.userData ? JSON.parse(e4.userData) : {}, i2 = { time: e4.time, action: e4.action, groupOnlineCount: t2.userAmount, groupId: t2.groupId, id: e4.userId, data: s2 };
      Zn.aec.fire(Qs.GROUP_PRESENCE, i2);
    });
  }
};
var En = class {
  get(e3) {
    Ws.validateId(e3.groupId, "groupId"), e3.groupId = e3.groupId.toString();
    let t2 = new As({ name: Os.imGroupOnlineCount, params: { groupId: e3.groupId }, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: function(t3) {
      xs.onFailed(e3, t3 || { code: 408, content: "Failed to query online group users" });
    }, success: function(t3) {
      200 == t3.code ? xs.onSuccess(e3, t3) : xs.onFailed(e3, t3);
    } });
    Ds.e(t2);
  }
};
var vn = class {
  doHereNow(e3, t2, s2) {
    let i2 = new As({ name: e3, params: t2, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e4) => {
      xs.onFailed(s2, e4);
    }, success: (e4) => {
      let t3 = e4.content;
      e4.content = t3.map((e5) => {
        let t4 = e5.userData ? JSON.parse(e5.userData) : {};
        return { id: e5.userId, data: t4 };
      }), xs.onSuccess(s2, e4);
    } });
    Ds.e(i2);
  }
};
var Cn = class extends vn {
  hereNow(e3) {
    Ws.validateId(e3.groupId, "groupId"), e3.groupId = e3.groupId.toString();
    let t2 = { groupId: e3.groupId };
    this.doHereNow(Os.imGroupHereNow, t2, e3);
  }
};
var Sn = class {
  constructor() {
    Ds.s().addMessageObserver(Ys.userPresence, this.newMessageReceived.bind(this));
  }
  presence(e3) {
    Ws.validateIdArray(e3.userIds, "userIds"), e3.userIds.toString().split(",");
    let t2 = { userIds: e3.userIds };
    this.emitRocket(Os.subscribeUserPresence, t2, () => {
      xs.onSuccess(e3, { code: 200, content: "ok" });
    }, (t3) => {
      xs.onFailed(e3, { code: t3.code || 408, content: t3.content || "Failed to subscribe group message" });
    }, Rs.commonRequestSingle, Rs.commonRequestTotal);
  }
  unPresence(e3) {
    Ws.validateId(e3.userId, "userId"), e3.userId = e3.userId.toString();
    let t2 = { userId: e3.userId };
    this.emitRocket(Os.unsubscribeUserPresence, t2, () => {
      xs.onSuccess(e3, { code: 200, content: "ok" });
    }, (t3) => {
      xs.onFailed(e3, { code: t3.code || 408, content: t3.content || "Failed to unsubscribe presence" });
    }, Rs.commonRequestSingle, Rs.commonRequestTotal);
  }
  emitRocket(e3, t2, s2, i2, n2, o2) {
    let r2 = new As({ name: e3, params: t2, singleTimeout: n2, totalTimeout: o2, permission: Jt.WRITE, success: s2, fail: i2 });
    Ds.e(r2);
  }
  newMessageReceived(e3) {
    let t2 = [];
    e3.c && (t2 = JSON.parse(e3.c).events || []), t2.map((e4) => {
      let t3 = e4.userData ? JSON.parse(e4.userData) : {}, s2 = { time: e4.time, action: e4.action, id: e4.userId, data: t3 };
      Zn.aec.fire(Qs.USER_PRESENCE, s2);
    });
  }
};
var bn = class extends vn {
  hereNow(e3) {
    let t2 = e3.userIds;
    Ws.validateIdArray(t2, "userIds"), t2.toString().split(","), this.doHereNow(Os.imHereNow, e3, e3);
  }
};
var wn = new class {
  fileExtension(e3, t2) {
    if (es.isString(e3))
      try {
        let s2 = e3.split(t2);
        return s2[s2.length - 1];
      } catch (e4) {
        throw Error(e4);
      }
  }
}();
var In = class {
};
var Mn = class extends In {
  constructor() {
    super(...arguments), this.contentType = "", this.name = "", this.size = 0, this.url = "";
  }
};
var An = class extends Mn {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0;
  }
};
var Tn = class {
  build(e3) {
    this.validate(e3.createOptions);
    let t2 = this.create();
    return this.setPayload(e3, t2), t2;
  }
};
var Nn = class extends Tn {
  create() {
    return new Mn();
  }
  setPayload(e3, t2) {
    let s2 = t2, i2 = e3.createOptions.file;
    s2.url = i2.path, s2.name = i2.name, s2.size = i2.size, s2.contentType = i2.type, e3.complete = Promise.resolve();
  }
  validate(e3) {
    if (!es.isObject(e3))
      throw Error("it is an empty message.");
    if (!es.isDef(e3.file))
      throw Error("file is empty.");
  }
};
var Rn = class extends Nn {
  create() {
    return new An();
  }
  setPayload(e3, t2) {
    super.setPayload(e3, t2);
    let s2 = e3.createOptions.file, i2 = t2, n2 = s2.path || s2.tempFilePath, o2 = es.isEmpty(s2.name) || void 0 === s2.name ? n2 : s2.name;
    i2.name = "wx-image." + wn.fileExtension(o2, "."), i2.contentType = "image/" + wn.fileExtension(o2, "."), i2.url = n2, i2.size = s2.size, e3.complete = new Promise((e4, t3) => {
      wx.getImageInfo({ src: i2.url, success(t4) {
        i2.width = t4.width, i2.height = t4.height, e4();
      }, fail(e5) {
        t3(e5);
      } });
    });
  }
  validate(e3) {
    super.validate(e3);
  }
};
var On = class extends Mn {
  constructor() {
    super(...arguments), this.duration = 0;
  }
};
var _n = class extends Nn {
  create() {
    return new On();
  }
  setPayload(e3, t2) {
    super.setPayload(e3, t2);
    let s2 = e3.createOptions.file, i2 = t2, n2 = s2.tempFilePath, o2 = es.isEmpty(s2.name) || null == s2.name ? n2 : s2.name, r2 = s2.duration, a2 = s2.fileSize;
    i2.url = n2, i2.size = a2, i2.duration = r2 / 1e3, i2.name = "wx-audio." + wn.fileExtension(o2, "."), i2.contentType = "audio/" + wn.fileExtension(o2, "."), e3.complete = Promise.resolve();
  }
  validate(e3) {
    super.validate(e3);
  }
};
var Pn = class extends In {
  constructor() {
    super(...arguments), this.text = "";
  }
};
var kn = class extends Tn {
  create() {
    return new Pn();
  }
  setPayload(e3, t2) {
    let s2 = t2, i2 = e3.createOptions;
    s2.text = i2.text, e3.complete = Promise.resolve();
  }
  validate(e3) {
    if (es.isEmpty(e3.text))
      throw { code: 400, content: "text is empty" };
    if (!es.isString(e3.text))
      throw { code: 400, content: "TypeError: text requires string." };
    if ("" === e3.text.trim())
      throw { code: 400, content: "text is empty" };
    if (e3.text.length > 2500)
      throw { code: 400, content: "Message text over max length 2500" };
  }
};
var Dn = class extends In {
  constructor() {
    super(...arguments), this.video = new Fn(), this.thumbnail = new xn();
  }
};
var xn = class {
  constructor() {
    this.name = "", this.url = "", this.width = 0, this.height = 0, this.contentType = "";
  }
  initURL(e3) {
    let t2 = It.currentPlatform();
    [vt.APP_IOS, vt.APP_ANDROID].includes(t2) ? this.appUrl(e3) : [vt.APPLET_WX, vt.APPLET_WX_GAME].includes(t2) ? this.wxUrl(e3) : this.htmlUrl(e3);
  }
  htmlUrl(e3) {
    let t2 = document.createElement("canvas");
    t2.width = e3.videoWidth, t2.height = e3.videoHeight, t2.getContext("2d").drawImage(e3, 0, 0, t2.width, t2.height), this.url = t2.toDataURL("image/png");
  }
  wxUrl(e3) {
  }
  appUrl(e3) {
  }
};
var Fn = class {
  constructor() {
    this.name = "", this.url = "", this.width = 0, this.height = 0, this.contentType = "", this.size = 0, this.duration = 0;
  }
};
var Un = class extends Tn {
  create() {
    return new Dn();
  }
  setPayload(e3, t2) {
    let s2 = e3.createOptions.file, i2 = t2, n2 = i2.video, o2 = i2.thumbnail, { duration: r2, height: a2, size: c2, tempFilePath: u2, thumbTempFilePath: l2, width: d2, name: h2 = "" } = s2, p2 = es.isEmpty(h2) ? u2 : h2;
    n2.contentType = "video/" + wn.fileExtension(p2, "."), n2.name = "wx-video." + wn.fileExtension(p2, "."), n2.url = u2, n2.width = o2.width = d2, n2.height = o2.height = a2, n2.size = c2, n2.duration = r2, o2.url = l2, o2.contentType = "image/jpg", o2.name = "wx-thumbnail.jpg", e3.complete = Promise.resolve();
  }
  validate(e3) {
    if (!es.isObject(e3))
      throw Error("it is an empty message.");
    if (!es.isDef(e3.file))
      throw Error("file is empty.");
  }
};
var Ln = class extends Tn {
  create() {
    return new Mn();
  }
  setPayload(e3, t2) {
    let s2 = t2, i2 = e3.createOptions.file;
    s2.url = i2.fullPath || i2.path, s2.name = i2.name, s2.size = i2.size, s2.contentType = i2.type, i2.type, e3.complete = Promise.resolve();
  }
  validate(e3) {
    if (!es.isObject(e3))
      throw Error("it is an empty message.");
    if (!es.isDef(e3.file))
      throw Error("file is empty.");
  }
};
var Gn = class extends Ln {
  create() {
    return new An();
  }
  setPayload(e3, t2) {
    let s2 = t2, i2 = e3.createOptions.file;
    s2.url = i2.path, s2.size = i2.size;
    let n2 = es.isEmpty(i2.name) || void 0 === i2.name ? i2.path : i2.name;
    s2.contentType = "image/" + wn.fileExtension(n2, "."), s2.name = "uni-image." + wn.fileExtension(n2, "."), e3.complete = new Promise((e4, t3) => {
      uni.getImageInfo({ src: i2.path, success(t4) {
        s2.width = t4.width, s2.height = t4.height, e4();
      }, fail(e5) {
        t3(e5);
      } });
    });
  }
  validate(e3) {
    super.validate(e3);
  }
};
var Bn = class extends Ln {
  create() {
    return new On();
  }
  setPayload(e3, t2) {
    let s2 = e3.createOptions, i2 = t2, n2 = s2.file, o2 = n2.tempFilePath, r2 = es.isEmpty(n2.name) || null == n2.name ? o2 : n2.name;
    i2.url = o2, i2.name = "uni-audio." + wn.fileExtension(r2, "."), i2.contentType = "audio/" + wn.fileExtension(r2, "."), e3.complete = new Promise((e4, t3) => {
      uni.getFileInfo({ filePath: o2, success: (n3) => {
        let r3 = n3.size;
        if (i2.size = r3, 0 === r3)
          e4();
        else if (es.isDef(s2.file.duration))
          i2.duration = s2.file.duration / 1e3, e4();
        else {
          const s3 = uni.createInnerAudioContext();
          s3.src = o2, s3.onCanplay(function(n4) {
            n4.errCode ? (s3.destroy(), t3(n4)) : (i2.duration = s3.duration, s3.destroy(), e4());
          }), s3.onError((i3) => {
            s3.destroy(), -99 === i3.errCode ? e4() : t3(i3);
          });
        }
      }, fail(e5) {
        t3(e5);
      } });
    });
  }
  validate(e3) {
    super.validate(e3);
  }
};
var qn = class extends Tn {
  create() {
    return new Dn();
  }
  setPayload(e3, t2) {
    let s2 = e3.createOptions.file, i2 = t2, n2 = i2.video, o2 = i2.thumbnail, { duration: r2, height: a2, size: c2, tempFilePath: u2, width: l2, name: d2 = "" } = s2, h2 = es.isEmpty(d2) ? u2 : d2;
    n2.size = c2, n2.width = l2, n2.height = a2, n2.url = u2, n2.duration = r2, n2.contentType = "video/" + wn.fileExtension(h2, "."), n2.name = "uni-video." + wn.fileExtension(h2, "."), o2.url = u2, o2.height = 200, o2.width = Number((n2.width * o2.height / n2.height).toFixed(0)), o2.contentType = "image/jpg", o2.name = "uni-thumbnail.jpg", e3.complete = Promise.resolve();
  }
  validate(e3) {
    if (!es.isObject(e3))
      throw Error("it is an empty message.");
    if (!es.isDef(e3.file))
      throw Error("file is empty.");
  }
};
var jn = class extends Tn {
  create() {
    return new Mn();
  }
  setPayload(e3, t2) {
    let s2 = t2, i2 = e3.createOptions.file, n2 = window.URL || window.webkitURL;
    s2.url = n2.createObjectURL(i2), s2.name = i2.name, s2.size = i2.size, s2.contentType = i2.type, e3.complete = Promise.resolve();
  }
  validate(e3) {
    if (!es.isObject(e3))
      throw Error("it is an empty message.");
    if (!(e3.file instanceof File))
      throw Error("wrong file type.");
    if (0 == e3.file.size)
      throw Error("File size is 0.");
    if (e3.file.size > 524288e3)
      throw Error("message-length limit 30mib");
  }
};
var Vn = class extends jn {
  create() {
    return new An();
  }
  setPayload(e3, t2) {
    super.setPayload(e3, t2);
    let s2 = e3.createOptions.file, i2 = t2, n2 = window.URL || window.webkitURL, o2 = new Image();
    o2.src = n2.createObjectURL(s2), e3.complete = new Promise((e4, t3) => {
      o2.onload = function() {
        i2.width = o2.width, i2.height = o2.height, n2.revokeObjectURL(o2.src), e4();
      }, o2.onerror = function(e5) {
        n2.revokeObjectURL(o2.src), t3(e5);
      };
    });
  }
  validate(e3) {
    super.validate(e3);
    let t2 = ["gif", "jpg", "png", "jpeg"];
    if (!t2.find((t3) => t3 === e3.file.type.split("/")[1].toLowerCase()))
      throw Error("Only " + t2.join(",") + " is supported image.");
  }
};
var Hn = class extends jn {
  create() {
    return new On();
  }
  setPayload(e3, t2) {
    super.setPayload(e3, t2);
    let s2 = e3.createOptions.file, i2 = t2, n2 = window.URL || window.webkitURL, o2 = document.createElement("audio");
    o2.src = n2.createObjectURL(s2), e3.complete = new Promise((e4, t3) => {
      o2.onloadedmetadata = () => {
        i2.duration = o2.duration, n2.revokeObjectURL(o2.src), e4();
      }, o2.onerror = (e5) => {
        n2.revokeObjectURL(o2.src), t3(e5);
      };
    });
  }
  validate(e3) {
    super.validate(e3);
    let t2 = ["mp3", "ogg", "wav", "wma", "ape", "acc", "mpeg"];
    if (!t2.find((t3) => t3 === e3.file.type.split("/")[1].toLowerCase()))
      throw Error("Only " + t2.join(",") + " is supported audio.");
  }
};
var Wn = class extends Tn {
  create() {
    return new Dn();
  }
  setPayload(e3, t2) {
    let s2 = e3.createOptions.file, i2 = t2, n2 = i2.video, o2 = i2.thumbnail, r2 = window.URL || window.webkitURL, a2 = document.createElement("video");
    a2.src = r2.createObjectURL(s2), n2.size = s2.size, n2.name = s2.name, n2.contentType = s2.type, n2.url = a2.src, o2.name = s2.name, o2.contentType = "image/jpg", e3.complete = new Promise((e4, t3) => {
      a2.onloadedmetadata = () => {
        n2.duration = a2.duration, n2.width = a2.videoWidth, n2.height = a2.videoHeight, o2.width = a2.videoWidth, o2.height = a2.videoHeight, o2.url = this.getThumbnailUrl(a2), r2.revokeObjectURL(a2.src), e4();
      }, a2.onerror = function(e5) {
        r2.revokeObjectURL(a2.src), t3(e5);
      };
    });
  }
  getThumbnailUrl(e3) {
    let t2 = document.createElement("canvas");
    return t2.width = e3.videoWidth, t2.height = e3.videoHeight, t2.getContext("2d").drawImage(e3, 0, 0, t2.width, t2.height), t2.toDataURL("image/png");
  }
  validate(e3) {
    if (!es.isObject(e3))
      throw Error("it is an empty message.");
    if (!(e3.file instanceof File))
      throw Error("wrong file type.");
    if (0 == e3.file.size)
      throw Error("File size is 0.");
    if (e3.file.size > 31457280)
      throw Error("message-length limit 30mib");
    let t2 = ["avi", "mov", "rmvb", "rm", "flv", "mp4", "3gp", "quicktime"];
    if (!t2.find((t3) => t3 === e3.file.type.split("/")[1].toLowerCase()))
      throw Error("Only " + t2.join(",") + " is supported video.");
  }
};
var zn = class extends In {
};
var Xn = class extends Tn {
  create() {
    return new zn();
  }
  setPayload(e3, t2) {
    let s2 = e3.createOptions;
    t2.payload = s2.payload, e3.complete = Promise.resolve();
  }
  validate(e3) {
    let t2 = e3.type, s2 = e3.payload;
    if (es.isEmpty(t2))
      throw Error("type is empty.");
    if (!es.isString(t2))
      throw Error("type require a string");
    if (es.isEmpty(s2))
      throw Error("payload is empty.");
    if (!es.isPlainObject(s2) && !es.isStringOrNumber(s2))
      throw Error("payload require object | string | number.");
  }
};
var Jn = class {
  constructor(e3, t2) {
    this.type = e3, this.createOptions = t2;
  }
};
var Yn = class {
  constructor() {
    this.framework = Mt.currentFramework();
    const e3 = It.currentPlatform() === vt.APPLET_WX;
    this.payloadBuilders = { [Ct.UNIAPP]: { image: new Gn(), file: new Ln(), audio: new Bn(), video: new qn(), text: new kn() }, [Ct.NATIVE_APPLET_WX]: { image: new Rn(), file: new Nn(), audio: new _n(), video: new Un(), text: new kn() }, [Ct.UNKNOWN]: { image: new Vn(), file: new jn(), audio: new Hn(), video: new Wn(), text: new kn() }, [Ct.TARO]: { image: e3 ? new Rn() : new Vn(), file: e3 ? new Nn() : new jn(), audio: e3 ? new _n() : new Hn(), video: e3 ? new Un() : new Wn(), text: new kn() } };
  }
  buildMessage(e3, t2) {
    let s2 = this.payloadBuilders[this.framework][e3], i2 = new Jn(e3, t2);
    if (s2) {
      let e4 = s2.build(i2);
      i2.payload = e4;
    } else {
      let e4 = new Xn().build(i2);
      i2.payload = e4.payload;
    }
    let n2 = this.build(i2);
    return i2.complete.then(() => {
      xs.onSuccess(t2, n2);
    }).catch((e4) => {
      xs.onFailed(t2, e4);
    }), n2;
  }
  build(e3) {
    let t2, s2 = e3.type, i2 = e3.payload, n2 = e3.createOptions, o2 = n2.to, r2 = o2.type;
    return this.validate(n2), r2 === lo.GROUP ? (t2 = new Gi(), t2.groupId = o2.id.toString(), t2.senderData = Ds.ud()) : r2 === lo.PRIVATE ? (t2 = new Li(), t2.read = false, t2.receiverId = o2.id.toString()) : r2 === lo.CS && (t2 = new Bi(), t2.to = o2.id.toString(), t2.teamId = o2.id.toString(), t2.senderData = Ds.ud()), t2.senderId = Ds.u(), t2.messageId = Ms.get(), t2.payload = i2, t2.timestamp = Date.now(), t2.type = s2, t2.recalled = false, t2.status = ho.NEW, t2.buildOptions = e3, t2;
  }
  validate(e3) {
    const t2 = e3.to;
    if (!t2)
      throw new Error("message require property to.");
    if (!es.isObject(t2))
      throw new Error("TypeError: to requires an object.");
    if (!es.isObject(t2.data))
      throw new Error("TypeError: to.data requires an object.");
    if (!t2.type || t2.type !== lo.GROUP && t2.type !== lo.PRIVATE && t2.type !== lo.CS)
      throw new Error("message require property to.type");
    if (es.isEmpty(t2.id))
      throw new Error("message require property to.id");
    if (!es.isStringOrNumber(t2.id))
      throw new Error("to.id should be a string or number.");
    if (Ds.u() === t2.id)
      throw new Error("to.id can not be the same as your id.");
    es.isDef(e3.notification) && Ws.validateNotification(e3.notification), e3.wxmpTemplateMsg && Ws.validateWXMPTemplateMsg(e3.wxmpTemplateMsg);
  }
};
var Qn = class extends fn {
  onMessageReceived(e3) {
    if (e3.t === lo.CS) {
      let t2 = this.builder.build(e3);
      this.sendAck(t2);
      let s2 = ki.byIMMessage(t2);
      if (!on.get(s2).existsMessage(t2)) {
        if (t2.customerId() === Ds.u())
          this.createNotification(e3), Gs.fire(bi.MESSAGE_RECEIVED, t2), Zn.aec.fire(Qs.CS_MESSAGE_RECEIVED, t2);
        else {
          Zi.getInstance().queryTeams().then(() => {
            en.isMyMessage(t2) && this.createNotification(e3), Gs.fire(bi.CS_AGENT_MESSAGE_RECEIVED, t2);
          });
        }
      }
    }
  }
};
var $n = class {
  constructor(e3) {
    this.times = new Array();
    let t2 = e3[0], s2 = ki.byIMMessage(t2);
    this.scene = s2.scene, this.targetId = s2.id, e3.forEach((e4) => {
      this.times.push(e4.timestamp);
    }), this.times.sort((e4, t3) => e4 < t3 ? -1 : e4 == t3 ? 0 : 1);
  }
};
var Kn = class {
  constructor() {
    Ds.s().addMessageObserver(Ys.IM_MSG_RECALLED, this.onRemoteRecalled.bind(this));
  }
  recallMessage(e3) {
    return t(this, void 0, void 0, function* () {
      nn.validateMessageArray(e3.messages), this.validate(e3);
      let t2 = e3.messages;
      yield this.recallServerMessages(t2);
      let s2 = t2[0], i2 = s2.scene(), n2 = this.toConversationId(i2, s2.senderId, s2.targetId()), o2 = { id: Ds.u(), data: Ds.ud() }, r2 = t2.map((e4) => e4.timestamp), a2 = new zi(i2, n2, o2, r2);
      Gs.fire(bi.MESSAGE_RECALLED, a2), xs.onSuccess(e3);
    });
  }
  onRemoteRecalled(e3) {
    Gs.fire(bi.MESSAGE_RECALLED, e3);
  }
  toConversationId(e3, t2, s2) {
    if (lo.PRIVATE === e3)
      return function(e4, t3) {
        return e4.localeCompare(t3) > 0 ? `${e4}:${t3}` : `${t3}:${e4}`;
      }(t2, s2);
    if (lo.GROUP === e3)
      return s2;
    throw { code: 400, content: `scene: ${e3} not support` };
  }
  recallServerMessages(e3) {
    let t2 = new $n(e3);
    return 0 === t2.times.length ? Promise.resolve() : new Promise((e4, s2) => {
      let i2 = new As({ name: Os.IM_RECALL_MESSAGE, params: t2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e5) => {
        s2(e5);
      }, success: (t3) => {
        200 === t3.code ? e4(t3) : s2(t3);
      } });
      Ds.e(i2);
    });
  }
  validate(e3) {
    let t2 = e3.messages;
    for (let e4 = 0; e4 < t2.length; e4++) {
      let s2 = t2[e4];
      if (s2.scene() === lo.CS)
        throw { code: 400, content: "Recall CS message is not supported yet." };
      if (s2.status !== ho.SUCCESS)
        throw { code: 400, content: "message[" + e4 + "] is '" + s2.status + "' and cannot be recalled" };
      if (s2.recalled)
        throw { code: 400, content: "message[" + e4 + "] has been recalled" };
      if (s2.senderId !== Ds.u())
        throw { code: 400, content: "it is not allowed to recall messages sent by others" };
    }
  }
};
var Zn = class _Zn {
  constructor(e3) {
    this._iMReceiver = new fn(), this.csMessageReceiver = new Qn(), this.options = e3, _Zn.aec = new oi(), this._userHereNow = new bn(), this.goEasyUploader = new vi(), this._groupHereNow = new Cn(), this._groupOnlineCount = new En(), this.groupMessageSubscriber = new gn();
  }
  static init(e3) {
    _Zn.instance = new _Zn(e3);
  }
  afterConnect() {
    this._iMReceiver.initialGoEasySocket(), this.csMessageReceiver.initialGoEasySocket(), this.messageBuilder = new Yn(), this.messageSender = new Oi(), this.recaller = new Kn(), this.histories = on.init(), this.histories.initialListeners(), this.conversations = new mn(), this._groupPresenceSubscriber = new yn(), this._userPresenceSubscriber = new Sn();
  }
  validateModules() {
    if (es.isUndef(Ds.s()))
      throw Error("Please call connect() first.");
    if (!this.options.modules || !this.options.modules.includes(_s))
      throw Error(`Invalid options: module '${_s}' is not enabled`);
  }
  catch(e3, s2) {
    return t(this, void 0, void 0, function* () {
      try {
        this.validateModules(), Ws.validateCallbackOptions(s2), yield e3();
      } catch (e4) {
        xs.onFailed(s2, e4);
      }
    });
  }
  on(e3, t2) {
    _Zn.aec.on(e3, t2);
  }
  off(e3, t2) {
    _Zn.aec.off(e3, t2);
  }
  createTextMessage(e3) {
    return this.validateModules(), this.messageBuilder.buildMessage(Si.TEXT, e3);
  }
  createImageMessage(e3) {
    return this.validateModules(), this.messageBuilder.buildMessage(Si.IMAGE, e3);
  }
  createFileMessage(e3) {
    return this.validateModules(), this.messageBuilder.buildMessage(Si.FILE, e3);
  }
  createAudioMessage(e3) {
    return this.validateModules(), this.messageBuilder.buildMessage(Si.AUDIO, e3);
  }
  createVideoMessage(e3) {
    return this.validateModules(), this.messageBuilder.buildMessage(Si.VIDEO, e3);
  }
  createCustomMessage(e3) {
    return this.validateModules(), this.messageBuilder.buildMessage(e3.type, e3);
  }
  sendMessage(e3) {
    this.catch(() => {
      this.messageSender.send(e3);
    }, e3);
  }
  recallMessage(e3) {
    this.catch(() => {
      this.recaller.recallMessage(e3);
    }, e3);
  }
  deleteMessage(e3) {
    this.catch(() => {
      this.histories.deleteMessage(e3);
    }, e3);
  }
  markGroupMessageAsRead(e3) {
    this.catch(() => t(this, void 0, void 0, function* () {
      yield this.histories.groupMarkAsRead(e3);
    }), e3);
  }
  markPrivateMessageAsRead(e3) {
    this.catch(() => t(this, void 0, void 0, function* () {
      yield this.histories.privateMarkAsRead(e3);
    }), e3);
  }
  markMessageAsRead(e3, s2) {
    this.catch(() => t(this, void 0, void 0, function* () {
      yield this.histories.markMessageAsRead(e3, s2);
    }), e3);
  }
  latestConversations(e3) {
    this.validateModules(), this.conversations.latestConversations(e3);
  }
  removePrivateConversation(e3) {
    this.catch(() => this.conversations.removePrivateConversation(e3), e3);
  }
  removeGroupConversation(e3) {
    this.catch(() => this.conversations.removeGroupConversation(e3), e3);
  }
  topPrivateConversation(e3) {
    this.catch(() => this.conversations.topPrivateConversation(e3), e3);
  }
  topGroupConversation(e3) {
    this.catch(() => this.conversations.topGroupConversation(e3), e3);
  }
  history(e3, t2) {
    this.catch(() => {
      this.histories.loadHistory(e3, t2);
    }, e3);
  }
  subscribeUserPresence(e3) {
    this.catch(() => this._userPresenceSubscriber.presence(e3), e3);
  }
  unsubscribeUserPresence(e3) {
    this.catch(() => this._userPresenceSubscriber.unPresence(e3), e3);
  }
  hereNow(e3) {
    this.catch(() => this._userHereNow.hereNow(e3), e3);
  }
  subscribeGroup(e3) {
    this.catch(() => this.groupMessageSubscriber.subscribe(e3), e3);
  }
  unsubscribeGroup(e3) {
    this.catch(() => this.groupMessageSubscriber.unsubscribe(e3), e3);
  }
  subscribeGroupPresence(e3) {
    this.catch(() => this._groupPresenceSubscriber.presence(e3), e3);
  }
  unsubscribeGroupPresence(e3) {
    this.catch(() => this._groupPresenceSubscriber.unPresence(e3), e3);
  }
  groupHereNow(e3) {
    this.catch(() => this._groupHereNow.hereNow(e3), e3);
  }
  groupOnlineCount(e3) {
    this.catch(() => this._groupOnlineCount.get(e3), e3);
  }
  latestPendingConversations(e3) {
    this.validateModules(), this.conversations.latestPendingConversations(e3);
  }
  topConversation(e3) {
    this.validateModules(), this.conversations.topConversation(e3);
  }
  removeConversation(e3) {
    this.validateModules(), this.conversations.removeConversation(e3);
  }
};
var eo;
!function(e3) {
  e3.VIDEO = "VIDEO", e3.VOICE = "VOICE";
}(eo || (eo = {}));
var to = class {
  constructor(e3, t2) {
    this.customerId = e3, this.teamId = t2;
  }
};
var so = class {
  constructor(e3, t2) {
    this.teamId = e3;
    let s2 = new fo(t2.id.toString(), JSON.stringify(t2.data));
    this.customer = s2;
  }
};
var io = class {
  constructor(e3, t2, s2) {
    this.customerId = e3, this.teamId = t2, this.agentId = s2;
  }
};
var no = class {
  constructor(e3, t2) {
    this.customerId = e3, this.teamId = t2;
  }
};
var oo = class {
  constructor(e3) {
    this.builder = new qi(), this.teamId = e3;
  }
  accept(e3, t2) {
    let s2 = t2.customer;
    if (es.isUndef(s2))
      throw { code: 400, content: "customer is required." };
    Ws.validateId(s2.id, "customer.id");
    let i2 = s2.data;
    if (es.isUndef(i2) || !es.isObject(i2))
      throw { code: 400, content: "customer data must be non-empty object." };
    let n2 = new so(e3, s2), o2 = new As({ name: Os.CS_ACCEPT, params: n2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e4) => {
      xs.onFailed(t2, e4);
    }, success: (e4) => {
      let s3 = this.builder.build(e4.content.message);
      Gs.fire(bi.CS_ACCEPTED, s3), xs.onSuccess(t2);
    } });
    Ds.e(o2);
  }
  end(e3, t2) {
    Ws.validateId(t2.id, "id");
    let s2 = t2.id.toString(), i2 = new no(s2, e3), n2 = new As({ name: Os.CS_END, params: i2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e4) => {
      xs.onFailed(t2, e4);
    }, success: (e4) => {
      let s3 = this.builder.build(e4.content.message);
      Gs.fire(bi.CS_ENDED, s3), xs.onSuccess(t2);
    } });
    Ds.e(n2);
  }
  queryCustomerStatus(e3, s2) {
    return t(this, void 0, void 0, function* () {
      Ws.validateId(s2.id, "id");
      let t2 = yield this.doCustomerStatus(e3, s2.id);
      this.activeCustomerStatus = t2, this.activeCustomerStatusOptions = s2, xs.onSuccess(s2, t2);
    });
  }
  doCustomerStatus(e3, t2) {
    let s2 = t2.toString(), i2 = new to(s2, e3);
    return new Promise((e4, t3) => {
      let s3 = new As({ name: Os.CS_CUSTOMER_STATUS, params: i2, permission: Jt.READ, singleTimeout: Rs.commonQuerySingle, totalTimeout: Rs.commonQueryTotal, fail: (e5) => {
        t3(e5);
      }, success: (t4) => {
        let s4 = t4.content;
        s4.agent && (s4.agent.data = JSON.parse(s4.agent.data)), e4(s4);
      } });
      Ds.e(s3);
    });
  }
  transfer(e3, t2) {
    Ws.validateId(t2.customerId, "customerId"), Ws.validateId(t2.agentId, "agentId");
    let s2 = t2.customerId.toString(), i2 = t2.agentId.toString(), n2 = new io(s2, e3, i2), o2 = new As({ name: Os.CS_TRANSFER, params: n2, permission: Jt.WRITE, singleTimeout: Rs.commonRequestSingle, totalTimeout: Rs.commonRequestTotal, fail: (e4) => {
      xs.onFailed(t2, e4);
    }, success: (e4) => {
      let s3 = this.builder.build(e4.content.message);
      Gs.fire(bi.CS_TRANSFER, s3), xs.onSuccess(t2);
    } });
    Ds.e(o2);
  }
};
var ro = class _ro {
  static getInstance() {
    return _ro.instance || (_ro.instance = new _ro()), _ro.instance;
  }
  createTextMessage(e3, t2) {
    let s2 = Zn.instance.createTextMessage(t2);
    this.extendProps(e3, s2);
  }
  createImageMessage(e3, t2) {
    let s2 = Zn.instance.createImageMessage(t2);
    this.extendProps(e3, s2);
  }
  createFileMessage(e3, t2) {
    let s2 = Zn.instance.createFileMessage(t2);
    this.extendProps(e3, s2);
  }
  createAudioMessage(e3, t2) {
    let s2 = Zn.instance.createAudioMessage(t2);
    this.extendProps(e3, s2);
  }
  createVideoMessage(e3, t2) {
    let s2 = Zn.instance.createVideoMessage(t2);
    this.extendProps(e3, s2);
  }
  createCustomMessage(e3, t2) {
    let s2 = Zn.instance.createCustomMessage(t2);
    this.extendProps(e3, s2);
  }
  extendProps(e3, t2) {
    if (t2.scene() === lo.CS) {
      let s2 = t2;
      s2.teamId = e3, s2.accepted = true;
    }
  }
};
var ao = class {
  constructor(e3) {
    this.teamId = e3, this.agentStatus = Zi.getInstance(), this.conversationHandler = new oo(e3), this.messageCreator = ro.getInstance();
  }
  catch(e3, s2) {
    return t(this, void 0, void 0, function* () {
      try {
        Ws.validateCallbackOptions(s2), yield e3();
      } catch (e4) {
        xs.onFailed(s2, e4);
      }
    });
  }
  isOnline(e3) {
    this.catch(() => {
      this.agentStatus.isOnline(this.teamId, e3);
    }, e3);
  }
  online(e3) {
    this.catch(() => {
      this.agentStatus.online(this.teamId, e3);
    }, e3);
  }
  offline(e3) {
    this.catch(() => {
      this.agentStatus.offline(this.teamId, e3);
    }, e3);
  }
  customerStatus(e3) {
    this.catch(() => {
      this.conversationHandler.queryCustomerStatus(this.teamId, e3);
    }, e3);
  }
  accept(e3) {
    this.catch(() => {
      this.conversationHandler.accept(this.teamId, e3);
    }, e3);
  }
  end(e3) {
    this.catch(() => {
      this.conversationHandler.end(this.teamId, e3);
    }, e3);
  }
  history(e3) {
    Zn.instance.history(e3, this.teamId);
  }
  markMessageAsRead(e3) {
    Zn.instance.markMessageAsRead(e3, this.teamId);
  }
  createTextMessage(e3) {
    this.messageCreator.createTextMessage(this.teamId, e3);
  }
  createImageMessage(e3) {
    this.messageCreator.createImageMessage(this.teamId, e3);
  }
  createFileMessage(e3) {
    this.messageCreator.createFileMessage(this.teamId, e3);
  }
  createAudioMessage(e3) {
    this.messageCreator.createAudioMessage(this.teamId, e3);
  }
  createVideoMessage(e3) {
    this.messageCreator.createVideoMessage(this.teamId, e3);
  }
  createCustomMessage(e3) {
    this.messageCreator.createCustomMessage(this.teamId, e3);
  }
  transfer(e3) {
    this.catch(() => {
      this.conversationHandler.transfer(this.teamId, e3);
    }, e3);
  }
  agents(e3) {
    this.catch(() => {
      this.agentStatus.agents(this.teamId, e3);
    }, e3);
  }
  liveSession(e3) {
    this.catch(() => {
      en.live(this.teamId, e3);
    }, e3);
  }
  quitLiveSession(e3) {
    this.catch(() => {
      en.quit(e3);
    }, e3);
  }
  listenCustomer(e3) {
    let t2 = { customerId: e3.id, onNewMessage: e3.onNewMessage, onStatusUpdated: e3.onStatusUpdated, onFailed: e3.onFailed, onSuccess: e3.onSuccess };
    this.catch(() => {
      en.live(this.teamId, t2);
    }, e3);
  }
  cancelListenCustomer(e3) {
    this.catch(() => {
      en.quit(e3);
    }, e3);
  }
};
var co = class {
  static team(e3) {
    Ws.validateId(e3, "teamId");
    let t2 = this.teams.get(e3);
    return t2 || (t2 = new ao(e3.toString()), this.teams.set(e3.toString(), t2)), t2;
  }
};
co.teams = /* @__PURE__ */ new Map();
var uo = class {
};
var lo;
var ho;
!function(e3) {
  e3.PRIVATE = "private", e3.GROUP = "group", e3.SYSTEM = "system", e3.CS = "cs";
}(lo || (lo = {})), function(e3) {
  e3.NEW = "new", e3.SENDING = "sending", e3.SUCCESS = "success", e3.FAIL = "fail";
}(ho || (ho = {}));
var po = class {
};
var mo = class extends uo {
};
var fo = class {
  constructor(e3, t2) {
    this.id = e3, this.data = t2;
  }
};
var go = class extends uo {
};
var yo = class {
  constructor(e3) {
    ii.init(e3);
  }
  initialGoEasySocket() {
    ii.instance.initialGoEasySocket();
  }
  initialBeforeConnect() {
    ii.instance.initialBeforeConnect();
  }
  publish(e3) {
    ii.instance.publish(e3);
  }
  subscribe(e3) {
    ii.instance.subscribe(e3);
  }
  unsubscribe(e3) {
    ii.instance.unsubscribe(e3);
  }
  subscribePresence(e3) {
    ii.instance.subscribePresence(e3);
  }
  unsubscribePresence(e3) {
    ii.instance.unsubscribePresence(e3);
  }
  history(e3) {
    ii.instance.history(e3);
  }
  hereNow(e3) {
    ii.instance.hereNow(e3);
  }
};
var Eo = class {
  constructor(e3) {
    Zn.init(e3);
  }
  afterConnect() {
    Zn.instance.afterConnect();
  }
  on(e3, t2) {
    Zn.instance.on(e3, t2);
  }
  off(e3, t2) {
    Zn.instance.off(e3, t2);
  }
  createTextMessage(e3) {
    return Zn.instance.createTextMessage(e3);
  }
  createImageMessage(e3) {
    return Zn.instance.createImageMessage(e3);
  }
  createFileMessage(e3) {
    return Zn.instance.createFileMessage(e3);
  }
  createAudioMessage(e3) {
    return Zn.instance.createAudioMessage(e3);
  }
  createVideoMessage(e3) {
    return Zn.instance.createVideoMessage(e3);
  }
  createCustomMessage(e3) {
    return Zn.instance.createCustomMessage(e3);
  }
  sendMessage(e3) {
    Zn.instance.sendMessage(e3);
  }
  recallMessage(e3) {
    Zn.instance.recallMessage(e3);
  }
  deleteMessage(e3) {
    Zn.instance.deleteMessage(e3);
  }
  markGroupMessageAsRead(e3) {
    Zn.instance.markGroupMessageAsRead(e3);
  }
  markPrivateMessageAsRead(e3) {
    Zn.instance.markPrivateMessageAsRead(e3);
  }
  latestConversations(e3) {
    Zn.instance.latestConversations(e3);
  }
  removePrivateConversation(e3) {
    Zn.instance.removePrivateConversation(e3);
  }
  removeGroupConversation(e3) {
    Zn.instance.removeGroupConversation(e3);
  }
  topPrivateConversation(e3) {
    Zn.instance.topPrivateConversation(e3);
  }
  topGroupConversation(e3) {
    Zn.instance.topGroupConversation(e3);
  }
  history(e3) {
    Zn.instance.history(e3);
  }
  subscribeUserPresence(e3) {
    Zn.instance.subscribeUserPresence(e3);
  }
  unsubscribeUserPresence(e3) {
    Zn.instance.unsubscribeUserPresence(e3);
  }
  hereNow(e3) {
    Zn.instance.hereNow(e3);
  }
  subscribeGroup(e3) {
    Zn.instance.subscribeGroup(e3);
  }
  unsubscribeGroup(e3) {
    Zn.instance.unsubscribeGroup(e3);
  }
  subscribeGroupPresence(e3) {
    Zn.instance.subscribeGroupPresence(e3);
  }
  unsubscribeGroupPresence(e3) {
    Zn.instance.unsubscribeGroupPresence(e3);
  }
  groupHereNow(e3) {
    Zn.instance.groupHereNow(e3);
  }
  groupOnlineCount(e3) {
    Zn.instance.groupOnlineCount(e3);
  }
  markMessageAsRead(e3) {
    Zn.instance.markMessageAsRead(e3);
  }
  csteam(e3) {
    return new Co(e3);
  }
  pendingConversations(e3) {
    Zn.instance.latestPendingConversations(e3);
  }
  topConversation(e3) {
    Zn.instance.topConversation(e3);
  }
  removeConversation(e3) {
    Zn.instance.removeConversation(e3);
  }
};
var vo = class _vo {
  constructor(t2) {
    if (es.isDef(_vo.instance) && _vo.instance.getConnectionStatus() !== e.DISCONNECTED)
      return _vo.instance;
    this.validateOptions(t2), At.init(t2.reactNativeOptions), this.options = t2, Fs.init(t2.allowNotification), this.pubsub = new yo(this.options), this.im = new Eo(this.options);
  }
  static getInstance(e3) {
    return es.isUndef(_vo.instance) && (_vo.instance = new _vo(e3)), _vo.instance;
  }
  setBadge(e3) {
    Fs.instance.setBadge(e3);
  }
  connect(t2) {
    this.getConnectionStatus() !== e.DISCONNECTED && es.isObject(t2) && es.isFunction(t2.onFailed) ? t2.onFailed({ code: 408, content: "It is already connected, don't try again until disconnect() is called. " }) : (this.confirmUserIdAndData(t2), Gs.initial(), this.pubsub.initialBeforeConnect(), this.goEasySocket = new Hs(this.options, t2), this.goEasySocket.connect(), Ds.i(this.goEasySocket), this.im.afterConnect(), this.pubsub.initialGoEasySocket());
  }
  disconnect(e3) {
    this.goEasySocket.disconnect().then(() => {
      es.isObject(e3) && es.isFunction(e3.onSuccess) && e3.onSuccess();
    }).catch((t2) => {
      es.isObject(e3) && es.isFunction(e3.onFailed) && e3.onFailed(t2);
    });
  }
  getConnectionStatus() {
    return this.goEasySocket ? this.goEasySocket.getStatus() : e.DISCONNECTED;
  }
  validateOptions(e3) {
    let t2 = "";
    if (!es.isObject(e3))
      throw t2 = "options is require an object.", Error(t2);
    if (!es.isPrimitive(e3.appkey) || 0 == e3.appkey.length)
      throw t2 = "Invalid options:'appkey' is empty.", Error(t2);
    if (!es.isPrimitive(e3.host) || 0 == e3.host.length)
      throw t2 = "Invalid options:'host' is empty.", Error(t2);
    if (!es.isArray(e3.modules))
      throw t2 = "Invalid options: 'modules' must be nonempty array", Error(t2);
    const s2 = [_s, Ps], i2 = e3.modules.map((e4) => {
      const i3 = e4.toUpperCase();
      if (!s2.includes(i3))
        throw t2 = `Invalid options: module '${e4}' is not support`, Error(t2);
      return i3;
    });
    e3.modules = i2;
  }
  onClickNotification(e3) {
    Fs.instance.onClickNotification(e3);
  }
  confirmUserIdAndData(e3) {
    if (this.options.modules.includes(_s)) {
      if (!es.isStringOrNumber(e3.id))
        throw { code: 400, content: "TypeError: id requires number or string." };
      if (!es.isObject(e3.data))
        throw { code: 400, content: "TypeError: data requires object." };
    } else if ("string" == typeof e3.id && e3.id.length > 60)
      throw { code: 400, content: "id over max length 60" };
  }
};
vo.version = "2.8.3", vo.IM_EVENT = Qs, vo.IM_SCENE = lo, vo.MEDIA_TYPE = eo;
var Co = class {
  constructor(e3) {
    this.id = e3;
  }
  isOnline(e3) {
    co.team(this.id).isOnline(e3);
  }
  online(e3) {
    co.team(this.id).online(e3);
  }
  offline(e3) {
    co.team(this.id).offline(e3);
  }
  customerStatus(e3) {
    co.team(this.id).customerStatus(e3);
  }
  accept(e3) {
    co.team(this.id).accept(e3);
  }
  end(e3) {
    co.team(this.id).end(e3);
  }
  history(e3) {
    co.team(this.id).history(e3);
  }
  markMessageAsRead(e3) {
    co.team(this.id).markMessageAsRead(e3);
  }
  createTextMessage(e3) {
    co.team(this.id).createTextMessage(e3);
  }
  createImageMessage(e3) {
    co.team(this.id).createImageMessage(e3);
  }
  createFileMessage(e3) {
    co.team(this.id).createFileMessage(e3);
  }
  createAudioMessage(e3) {
    co.team(this.id).createAudioMessage(e3);
  }
  createVideoMessage(e3) {
    co.team(this.id).createVideoMessage(e3);
  }
  createCustomMessage(e3) {
    co.team(this.id).createCustomMessage(e3);
  }
  transfer(e3) {
    co.team(this.id).transfer(e3);
  }
  agents(e3) {
    co.team(this.id).agents(e3);
  }
  liveSession(e3) {
    co.team(this.id).liveSession(e3);
  }
  quitLiveSession(e3) {
    co.team(this.id).quitLiveSession(e3);
  }
  listenCustomer(e3) {
    co.team(this.id).listenCustomer(e3);
  }
  cancelListenCustomer(e3) {
    co.team(this.id).cancelListenCustomer(e3);
  }
};
export {
  mo as AgentOnlineOptions,
  Co as CSTeam,
  uo as CallBackOptions,
  po as ConversationDTO,
  go as CustomerStatusOptions,
  Eo as GoEasyIM,
  yo as GoEasyPubSub,
  ho as MessageStatus,
  lo as Scene,
  fo as User,
  vo as default
};
//# sourceMappingURL=@_node_modules_GOEASY-IM_js_sdk_goeasy-2__8__3__esm__min__js.js.map
